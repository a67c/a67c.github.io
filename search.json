[{"title":"我们仍未知道那天wda为什么没有被启动","url":"/2018/04/16/201804162116/","content":" 这是一篇废话连篇的佛系记录，本文主要为appium+wda测试app过程中遇到的问题\n\n#### 1.appium报错说明：\n\n```\nurllib2.URLError: <urlopen error [Errno 61] Connection refused>\n```\n该问题为什么会发生至今仍不知道，一方面说是当前appium服务端没有被启动，但是在appium服务端启动之后仍曾经遇到过这个问题，无组织无纪律2%的概率复现。\n\n**当前解决方式:通过增加重试次数重启appium**\n#### 2.socket hang up\n\n```\nCould not proxy command to remote server. Original error: Error: socket hang up\n```\n\nappium服务端挂起，该问题由于appium服务端什么原因导致尚未查明，每隔一段时间总会hang up一次。\n**假装解决方式：选择在python脚本中对其异常进行捕获**\n但是这个问题总是要查的……\n\n#### 3.找不到证书\n\n```\nError: App with bundle identifier 'xxxxxx'\n```\n遇到这个问题一种是真的证书写错了，另一种，在程序执行了好久后报这个错误那就非常奇怪了……奇怪到至今也没有查到这个问题，但可以确定的是，随着mac连接设备不再频繁掉设备后，这个问题也逐渐减少了。\n\n\n#### 4.找不到设备\n\n```\n Message: An unknown server-side error occurred while processing the command. Original error: Unknown device or simulator UDID: 'balabalabalalbas'\n```\n大意就是找不到设备，尤其是在程序执行一段时间后失败了，失败原因找不到设备，就好像之前执行的一个小时都在闹着玩一样。\n此时ituns会弹出各种弹框：eg'当前找不到该设备' ‘无法像该设备传输信息’\n所以简单粗暴的认为是设备掉线了，后来更换了HUB之后，该问题果然减少了！**更换HUB**之后连带着找不到证书的问题也**果然**减少了！\n\n#### httplib.BadStatusLine\n\n```\nraise BadStatusLine(line) httplib.BadStatusLine: ''\n```\n网上查说是你的python请求中断啊，但是为什么会中断！网络好好的，什么都好好的，后来终于确定了现场，那就是报出该问题时99%是app证书没有被信任，暂定就破案吧。\n\n#### 5.Too many instances\n\n```\n Too many instances of this services are already running\n```\n如果你的appium日志经常阵亡在wda启动时，满屏都是wda报错的日志时，不妨从xcodebuild中启动一下wda，经常会出现这个错误！除了重启手机别无它法。\n\n#### 6.A session is either terminated or not started\n```\nWebDriverException: Message: A session is either terminated or not started\n```\n大概就是当前的session已经停止了，再去连接是连接不上的，捕获到这种异常后，进行了appium重新请求，即重新建立appium与wda，wda与手机的session\n\n#### 7.wda没有启动\n\n```\nWebDriverException: Message: An unknown server-side error occurred while processing the command. Original error: An error occurred\n```\nelement找不到，当前发送的命令webdriver中没有，都可能导致这个问题\n\n\n#### 8.xcodebuild65\n这个问题范围太广了，wda没有启动成功时，基本是成片的'xcodebuild 65'\n且如果你上次执行失败导致xcodebuild65 and wda remove，之后的执行基本也是失败的。此时主要是通过xcodebuild重启wda来尽量避免成片出现这种错误。\n当前可以确定的是：\n手机弹出未安装sim卡，手机弹出alertView弹窗，手机未被信任都会阻止wda的启动。\n重启手机，通过xcodebuild重启wda可以有效减少此类问题发生，但是可能不能避免。\n\n#### 总结\n重启手机、重启wda、避免手机电量不足而导致重新信任电脑、增加appium启动重试次数、更换硬件设备、对于异常进行捕获而非抛出，大概就是以上要表达的全部意思。","tags":["Appium"]},{"title":"关于wda启动之后iproxy转发后仍然无法访问8100地址查找记录","url":"/2018/04/16/201804061949/","content":"#### 成功现象说明：\n一般来说在wda启动之后会生成地址http:xxx:8100,通过iproxy转发端口后，在浏览器中输出127.0.0.1:8100/status，即可返回json字符串，从而在浏览器中观察到wda返回的字符串。【假设iproxy端口转发为8100.】\n\n#### 问题说明：\n但是单独启动wda之后，面临着http:xxx:8100/status不能正常返回json字符串的情况。\n\nxcodebuild中启动wda日志输出最后一行为\n```\nServerURLHere->http://172.24.39.75:0<-ServerURLHere\n```\n最后一行并没有输出8100！不同的版本表现的不同~\n在这种情况下通过iproxy转发8100端口 在浏览器中输出127.0.0.1:8100是找不到的。\n\n#### 解决方案：\n如何修改：\n通过命令行启动xcodebuild时加上`USE_PORT`参数来选定端口。*appium中更改wda端口也是通过这个参数来操作的*\n```\n/usr/bin/xcodebuild build-for-testing test-without-building -project /usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgent/WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination id=请传入设备的udid USE_PORT=8100 test\n```\n\n\n#### 问题查找过程blog记录：\n [Appium Destopv1.2.3 中 WDA 启动后监听 ip 和端口的疑问](https://testerhome.com/topics/10445)\n\n [How can i change WebdriverAgent port with command-line parameters ?](https://github.com/facebook/WebDriverAgent/issues/538)\n\n [Appium 1.7.1, WDA ServerURLHere->http://...:0<-ServerURLHere](https://github.com/appium/appium/issues/9547)\n\n [WDA does not listen port 8100 ](https://github.com/facebook/WebDriverAgent/issues/661#issuecomment-338920833)\n\n [关于端口转发iproxy](https://blog.yuhanle.com/2018/01/03/how-to-install-web-driver-agent-on-device/)","tags":["Appium"]},{"title":"关于搭建appium+wda环境时遇到的问题记录","url":"/2018/04/16/201804161919/","content":"#### xcodebuild报错：\n**各种路径请对应自己电脑上的路径**\n```\nstderr: xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance\n```\n解决：\n```\nsudo xcode-select --switch /Applications/Xcode6-Beta.app/Contents/Developer/\n```\n-----\n#### java环境配置\n```\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home   \n\nexport PATH=$JAVA_HOME/bin:$PATH \n\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n```\n------\n#### Homebrew报错\n```\n [Homebrew: Could not symlink, /usr/local/bin is not writable]\n\n```\n解决：\n```\nsudo chown -R `whoami`:admin /usr/local/bin\n```\n-------\n#### xcode报错：\n```\nxcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance  \n```\n\n解决：在命令行工具中输入下面的命令：\n\n```\nsudo xcode-select -s  /Applications/Xcode.app/Contents/Developer\n```\n\n#### icu4c问题：\n```\ndyld: Library not loaded: /usr/local/opt/icu4c/lib/libicui18n.61.dylib\n  Referenced from: /usr/local/bin/node\n  Reason: image not found\nAbort trap: 6\n```\n解决：\n```\nbrew install icu4c\nbrew link icu4c --force\n```\n\n#### wda报错\n```\nThis application’s application-identifier entitlement does not match that of the installed application. These values must match for an upgrade to be allowed.\n```\n在不同mac上测试时用的都是同一台手机，上个mac上装的wda可能不适合下一台，所以卸载了wda后  新环境可以正常安装wda\n\n#### openssl broken\n```\nError: /usr/local/opt/openssl not present or broken\nPlease reinstall openssl. Sorry :(\n\n```\nbrew install openssl\n安装之后准备 `brew link openssl`时报错，报错如下：\n```\nWarning: Refusing to link: openssl\nLinking keg-only openssl means you may end up linking against the insecure,\ndeprecated system OpenSSL while using the headers from Homebrew's openssl.\nInstead, pass the full include/library paths to your compiler e.g.:\n  -I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib\n```\nbrew link openssl --force仍然报错\n最终输入：\n```\nln -s /usr/local/opt/openssl/lib/libcrypto.1.0.0.dylib /usr/local/lib/\n\nln -s /usr/local/opt/openssl/lib/libssl.1.0.0.dylib /usr/local/lib/\n\n```\nopenssl问题解决来源于[该blog](https://blog.csdn.net/jiamian_/article/details/55098125)\n","tags":["Appium环境搭建"]},{"title":"Appium在vscode中调试说明","url":"/2018/02/22/201802221759/","content":"#### 需求说明\n要对appium的源码进行调试，如果选择全局安装的难免会在调试过程中破坏原代码，因此从github上面拉下了master分支的代码进行调试   [github代码：](https://github.com/appium/appium.git)\n\n#### 环境说明：\nvscode \n\nappium 1.7.2\n\nmac\n\n#### 安装appium\n\n要使拽下来的代码达到可运行状态，需要执行`npm install`但是这个安装过程中如果出现下载不成功的问题，原因可能是没有翻墙，导致无法下载chromedriver,因此建议翻箱后重新`npm install`\n\n#### 调试文件配置\n在vscode中打开appium所在的文件夹，要在debug时对vscode的launch.json进行配置,关于它的debug流程官网地址[https://code.visualstudio.com/docs/editor/debugging](https://code.visualstudio.com/docs/editor/debugging)介绍的比较详细，我用的launch.json配置如下：\n```launch.json\n{\n    // 使用 IntelliSense 了解相关属性。 \n    // 悬停以查看现有属性的描述。\n    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n\n        {\n            \"type\": \"node\",\n            \"request\": \"launch\",\n            \"name\": \"Launch Program\",\n            \"program\": \"${workspaceFolder}/build/lib/main.js\",//package.json中的默认入口\n            \"console\" : \"integratedTerminal\"  //控制台信息的显示\n        }\n    ]\n}\n```\n#### 运行\n\n调试文件运行好后，就可以在debug中运行按钮启动appium了，启动后就可以打断点进行调试了。\n\n#### 修改代码\n\n在appium调试过程中发现，文件夹中会有build和其它文件夹，而入口文件一般都在build文件夹下，可是build文件夹中的代码又是被转换过的，我们如果在非build文件下更改又不会生效，那么这个时候要怎么办呢？\n\n首先说原因，appium是用nodejs写成的，其中用了js的一些新特性，不能被直接识别执行，因此需要通过babel将代码转换一下，因此转换前的代码在lib中，转换后的代码在build中，appium及其所有的类库都是这样的方式，转换时用的打包工具是gulp。\n\n由于执行的是build中的文件，而我们改代码都在转换前的文件夹lib下，所以需要对修改的代码进行打包。\n进入gulpfiles.js所在的文件夹下，执行\n```\nnpm run build\n```\n就可以将代码修改了。\n\n有时候调试代码时需要涉及到在node_modules\n中的`appium-base-driver`,`appium-xcuitest-driver`,`appium-android-driver`等各种类库中修改，这就需要我们在每一个类库中修改后都要进行打包,目前还没有找到gulp在node中的中间件，就是全部都打包的那种，之前只用过webpack的中间件，如果有小伙伴知道怎么在执行node时用gulp全部打包一下，还请告知哈。\n\n\n","tags":["Appium环境搭建"]},{"title":"Appium通过日志分析服务端执行过程-IOS端","url":"/2018/02/22/201802221449/","content":"\n#### 写在前面\n1. 本文日志为在IOS模拟器上进行的测试 appium 1.7.2\n2. 在appium服务端中，日志分为log.info和log.debug 一般每个文件夹下面都有logger.js 该js中规定当前log格式。\n3. info为基础信息，debug可以看做为调试信息。\n4. 本篇为初步分析，后来对日志又进行了更细致的断点查找，待整理，如有错误还请指出\n5. 假如日志前面打印出的[Appium][XUCITES]等，根据该名字可以查到日志来源于哪个文件夹下，[debug][MJSONWP]代表当前是采用log.debug方式打印日志，且日志来源于`appium-base-driver/mjsonwp`的文件夹\n\n#### 第一部分 启动服务并创建sessionID\nappium启动：\n```\n[Appium] Welcome to Appium v1.7.2\n[Appium] Appium REST http interface listener started on 0.0.0.0:4723\n```\n客户端发送http请求，并传递配置参数\n```\n[HTTP] --> POST /wd/hub/session {\"capabilities\":{\"alwaysMatch\":{\"platformName\":\"iOS\"},\"firstMatch\":[{}]},\"desiredCapabilities\":{\"platformVersion\":\"11.2\",\"deviceName\":\"iPhone 6s\",\"app\":\"/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app\",\"platformName\":\"iOS\"}}\n```\n[MJSONWP]为来自于appium服务端中封装好的类库`appium-base-driver`中mjsonwp文件夹下的mjsonwp.js，一般用于server端的交互，包括处理HTTP的请求，session会话的创建删除。以下为创建Session\n```\n[debug] [MJSONWP] Calling AppiumDriver.createSession() with args: [{\"platformVersion\":\"11.2\",\"deviceName\":\"iPhone 6s\",\"app\":\"/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app\",\"platformName\":\"iOS\"},null,{\"alwaysMatch\":{\"platformName\":\"iOS\"},\"firstMatch\":[{}]}]\n```\n[BaseDriver]日志来源于`appium-base-driver/basedriver`文件夹。\n下面日志主要用于打印整个appium中的事件触发，所有的请求都会触发各种类下的`executeCommand`函数，而这些函数全部继承driver.js中的WebDriver，所以所有的请求都会打印出`driver.js`中的logHistory。\n```\n[debug] [BaseDriver] Event 'newSessionRequested' logged at 1516514435268 (14:00:35 GMT+0800 (CST))\n ```\n[Appium]日志来源于`lib`文件夹下\n```\n[Appium] Merged W3C capabilities {\"alwaysMatch\":{\"platformName\":\"iOS\"},\"firstMat... into desiredCapabilities object {\"platformVersion\":\"11.2\",\"deviceName\":\"iPhone ...\n[Appium] Requested iOS support with version >= 10, using XCUITest driver instead of UIAutomation-based driver, since the latter is unsupported on iOS 10 and up.\n[Appium] Creating new XCUITestDriver (v2.64.0) session\n[Appium] Capabilities:\n[Appium]   platformVersion: 11.2\n[Appium]   deviceName: iPhone 6s\n[Appium]   app: /Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app\n[Appium]   platformName: iOS\n```\n[BaseDriver]打印出当前sessionId创建成功，来源于`appium-base-driver/basedriver/session.js`文件。\n\n* creatSession跳转过程说明：\n创建creatSession路线：mjsonwp.js-》appium.js中的createSession-》跳转到XCUITEST中的createSession-》跳转到appium-base-driver/basedriver/driver.js中的creatSession\n* 如何联系起了XCUITest？\n通过appium.js中的`curSessionDataForDriver(InnerDriver)`，当判断出当前是什么系统配置时，InnerDriver此时已变成IOS或者Android的Driver\n\n```\n[BaseDriver] Session created with session id: 8790f1db-9627-41ce-a534-bc40159c7194\n```\n当创建SessionID之后，此时进入的是`appium-xcuitest-driver`类库中。\n```\n[debug] [XCUITest] Current user: '用户名'\n[debug] [XCUITest] Current version of libimobiledevice: stable 1.2.0 (bottled), HEAD\n[debug] [XCUITest] Xcode version set to '9.2' (tools v9.2.0.0.1.1510905681)\n[debug] [XCUITest] iOS SDK Version set to '11.2'\n```\n来自于`appium-base-driver/basedriver/driver.js`中的logHistory函数\n```\n[debug] [BaseDriver] Event 'xcodeDetailsRetrieved' logged at 1516514436354 (14:00:36 GMT+0800 (CST))\n```\n[iOSSim]来自于`appium-ios-simulator`的日志，接下来都是在IOS检测模拟器，判断APP，安装APP的操作\n```\n[iOSSim] Constructing iOS simulator for Xcode version 9.2 with udid '2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5'\n[XCUITest] Determining device to run tests on: udid: '2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5', real device: false\n[BaseDriver] Using local app '/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app'\n[debug] [BaseDriver] Event 'appConfigured' logged at 1516514436692 (14:00:36 GMT+0800 (CST))\n[debug] [XCUITest] Checking whether app '/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app' is actually present on file system\n[debug] [XCUITest] App is present\n[debug] [iOS] Getting bundle ID from app '/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app': 'io.appium.TestApp'\n[debug] [BaseDriver] Event 'resetStarted' logged at 1516514436695 (14:00:36 GMT+0800 (CST))\n[XCUITest] Not scrubbing third party app in anticipation of uninstall\n[debug] [BaseDriver] Event 'resetComplete' logged at 1516514436881 (14:00:36 GMT+0800 (CST))\n[debug] [XCUITest] Starting log capture for iOS Simulator with udid '2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5', using 'xcrun simctl spawn 2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5 log stream --style compact'\n[debug] [BaseDriver] Event 'logCaptureStarted' logged at 1516514437312 (14:00:37 GMT+0800 (CST))\n[XCUITest] Setting up simulator\n[debug] [iOS] No reason to set locale\n[debug] [iOS] No iOS / app preferences to set\n[debug] [iOSSim] Matched 1 Simulator cache item for cleanup: /Users/用户名/Library/Developer/CoreSimulator/Devices/2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5/data/Library/Caches/com.apple.mobile.installd.staging\n[debug] [iOSSim] Setting common Simulator preferences to {\"ConnectHardwareKeyboard\":false}\n[debug] [iOSSim] Updated 2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5 Simulator preferences at '/Users/用户名/Library/Preferences/com.apple.iphonesimulator.plist' with {\"ConnectHardwareKeyboard\":false}\n[debug] [iOSSim] The count of running Simulator UI client instances is 1\n[iOSSim] Both Simulator with UDID 2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5 and the UI client are currently running\n[debug] [BaseDriver] Event 'simStarted' logged at 1516514437783 (14:00:37 GMT+0800 (CST))\n[debug] [XCUITest] Reset requested. Removing app with id 'io.appium.TestApp' from the device\n[debug] [XCUITest] Installing '/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app' on Simulator with UUID '2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5'...\n[debug] [XCUITest] The app has been installed successfully.\n[debug] [BaseDriver] Event 'appInstalled' logged at 1516514440337 (14:00:40 GMT+0800 (CST))\n```\nAPP安装成功之后开始处理WDA\n```\n[XCUITest] Using WDA path: '/usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgent'\n[XCUITest] Using WDA agent: '/usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgent/WebDriverAgent.xcodeproj'\n[debug] [XCUITest] No obsolete cached processes from previous WDA sessions listening on port 8100 have been found\n[debug] [JSONWP Proxy] Proxying [GET /status] to [GET http://localhost:8100/status] with no body\n[debug] [JSONWP Proxy] Got response with status 200: \"{\\n  \\\"value\\\" : {\\n    \\\"state\\\" : \\\"success\\\",\\n    \\\"os\\\" : {\\n      \\\"name\\\" : \\\"iOS\\\",\\n      \\\"version\\\" : \\\"11.2\\\",\\n      \\\"sdkVersion\\\" : \\\"11.2\\\"\\n    },\\n    \\\"ios\\\" : {\\n      \\\"simulatorVersion\\\" : \\\"11.2\\\",\\n      \\\"ip\\\" : \\\"192.168.0.102\\\"\\n    },\\n    \\\"build\\\" : {\\n      \\\"time\\\" : \\\"Jan 14 2018 23:25:10\\\"\\n    }\\n  },\\n  \\\"sessionId\\\" : \\\"17DE3FB9-3196-4C9C-9D55-3BFFDD0C1DEB\\\",\\n  \\\"status\\\" : 0\\n}\"\n[XCUITest] Will reuse previously cached WDA instance at 'http://localhost:8100/'. Set the wdaLocalPort capability to a value different from 8100 if this is an undesired behavior.\n[debug] [BaseDriver] Event 'wdaStartAttempted' logged at 1516514440422 (14:00:40 GMT+0800 (CST))\n[XCUITest] Using provided WebdriverAgent at 'http://localhost:8100/'\n[debug] [BaseDriver] Event 'wdaSessionAttempted' logged at 1516514440423 (14:00:40 GMT+0800 (CST))\n[debug] [XCUITest] Sending createSession command to WDA\n```\n在XCUITest中开启WDA之后，此时链接的request和response进入了  `appium-base-driver/lib/jsonwp-proxyproxy.js` ，这个js主要是做S/D的链接，即server服务端与devices设备的链接\n```\n[debug] [JSONWP Proxy] Proxying [GET /status] to [GET http://localhost:8100/status] with no body\n[debug] [JSONWP Proxy] Got response with status 200: \"{\\n  \\\"value\\\" : {\\n    \\\"state\\\" : \\\"success\\\",\\n    \\\"os\\\" : {\\n      \\\"name\\\" : \\\"iOS\\\",\\n      \\\"version\\\" : \\\"11.2\\\",\\n      \\\"sdkVersion\\\" : \\\"11.2\\\"\\n    },\\n    \\\"ios\\\" : {\\n      \\\"simulatorVersion\\\" : \\\"11.2\\\",\\n      \\\"ip\\\" : \\\"192.168.0.102\\\"\\n    },\\n    \\\"build\\\" : {\\n      \\\"time\\\" : \\\"Jan 14 2018 23:25:10\\\"\\n    }\\n  },\\n  \\\"sessionId\\\" : \\\"17DE3FB9-3196-4C9C-9D55-3BFFDD0C1DEB\\\",\\n  \\\"status\\\" : 0\\n}\"\n[debug] [JSONWP Proxy] Proxying [POST /session] to [POST http://localhost:8100/session] with body: {\"desiredCapabilities\":{\"bundleId\":\"io.appium.TestApp\",\"arguments\":[],\"environment\":{},\"shouldWaitForQuiescence\":true,\"shouldUseTestManagerForVisibilityDetection\":false,\"maxTypingFrequency\":60,\"shouldUseSingletonTestManager\":true}}\n[debug] [JSONWP Proxy] Got response with status 200: {\"value\":{\"sessionId\":\"95403F32-CD9B-4A0E-AA89-4BE9C899FBBC\",\"capabilities\":{\"device\":\"iphone\",\"browserName\":\"TestApp\",\"sdkVersion\":\"11.2\",\"CFBundleIdentifier\":\"io.appium.TestApp\"}},\"sessionId\":\"95403F32-CD9B-4A0E-AA89-4BE9C899FBBC\",\"status\":0}\n[debug] [BaseDriver] Event 'wdaSessionStarted' logged at 1516514443103 (14:00:43 GMT+0800 (CST))\n[debug] [BaseDriver] Event 'wdaStarted' logged at 1516514443103 (14:00:43 GMT+0800 (CST))\n[XCUITest] Skipping setting of the initial display orientation. Set the \"orientation\" capability to either \"LANDSCAPE\" or \"PORTRAIT\", if this is an undesired behavior.\n[debug] [BaseDriver] Event 'orientationSet' logged at 1516514443103 (14:00:43 GMT+0800 (CST))\n```\n上边WDA开启完毕，session创建成功，这个session的创建过程是从\n\n**mjsonwp.js（HTTP请求入口）-》appium.js中的createSession-》跳转到XCUITEST中的createSession-》跳转到appium-base-driver/basedriver/driver.js中的creatSession   创建成功之后回到了appium.js中将log打印，最后回到了mjsonwp.js将response返回并通知。**\n\n\n```\n[Appium] New XCUITestDriver session created successfully, session 8790f1db-9627-41ce-a534-bc40159c7194 added to master session list\n[debug] [BaseDriver] Event 'newSessionStarted' logged at 1516514443104 (14:00:43 GMT+0800 (CST))\n[debug] [MJSONWP] Responding to client with driver.createSession() result: {\"webStorageEnabled\":false,\"locationContextEnabled\":false,\"browserName\":\"\",\"platform\":\"MAC\",\"javascriptEnabled\":true,\"databaseEnabled\":false,\"takesScreenshot\":true,\"networkConnectionEnabled\":false,\"platformVersion\":\"11.2\",\"deviceName\":\"iPhone 6s\",\"app\":\"/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app\",\"platformName\":\"iOS\",\"udid\":\"2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5\"}\n[HTTP] <-- POST /wd/hub/session 200 7841 ms - 515\n```\n---------\n#### 第二部分 发送操作请求执行并返回\n\n客户端传来请求获取element，该请求进入mjsonwp.js进行处理，通过executeCommand函数进入appium.js 进入appium-xcuitest-driver‘类库 与JSONWP Proxy[appium-base-driver/lib/jsonwp/proxy.js]进行协议交互  交互结果返回MJSONWP[appium-base-driver/lib/mjsonwp/mjsonwp.js]\n```\n[HTTP] --> POST /wd/hub/session/8790f1db-9627-41ce-a534-bc40159c7194/element {\"using\":\"accessibility id\",\"sessionId\":\"8790f1db-9627-41ce-a534-bc40159c7194\",\"value\":\"TextField1\"}\n[debug] [MJSONWP] Calling AppiumDriver.findElement() with args: [\"accessibility id\",\"TextField1\",\"8790f1db-9627-41ce-a534-bc40159c7194\"]\n[debug] [XCUITest] Executing command 'findElement'\n[debug] [BaseDriver] Valid locator strategies for this request: xpath, id, name, class name, -ios predicate string, -ios class chain, accessibility id\n[debug] [BaseDriver] Waiting up to 0 ms for condition\n[debug] [JSONWP Proxy] Proxying [POST /element] to [POST http://localhost:8100/session/95403F32-CD9B-4A0E-AA89-4BE9C899FBBC/element] with body: {\"using\":\"accessibility id\",\"value\":\"TextField1\"}\n[debug] [JSONWP Proxy] Got response with status 200: {\"value\":{\"ELEMENT\":\"A3063789-1A9E-4FA2-A645-F2E257F0BB30\"},\"sessionId\":\"95403F32-CD9B-4A0E-AA89-4BE9C899FBBC\",\"status\":0}\n[debug] [MJSONWP] Responding to client with driver.findElement() result: {\"ELEMENT\":\"A3063789-1A9E-4FA2-A645-F2E257F0BB30\"}\n[HTTP] <-- POST /wd/hub/session/8790f1db-9627-41ce-a534-bc40159c7194/element 200 83 ms - 122\n```\n客户端再次传来请求，以下都是重复请求与返回，直到客户端传来删除会话。\n当客户端单个任务执行完毕时，客户端传来删除会话，通讯与其它没有什么差别。\n```\n[HTTP] --> DELETE /wd/hub/session/5469f63c-9b2b-4a3a-bbdb-fa26bd6315f9 {}\n[debug] [MJSONWP] Calling AppiumDriver.deleteSession() with args: [\"5469f63c-9b2b-4a3a-bbdb-fa26bd6315f9\"]\n[debug] [BaseDriver] Event 'quitSessionRequested' logged at 1516514455122 (14:00:55 GMT+0800 (CST))\n[Appium] Removing session 5469f63c-9b2b-4a3a-bbdb-fa26bd6315f9 from our master session list\n[debug] [JSONWP Proxy] Proxying [DELETE /session/5469f63c-9b2b-4a3a-bbdb-fa26bd6315f9] to [DELETE http://localhost:8100/session/E9944FDA-46DC-48B4-824B-A2C99D0B3BD2] with no body\n[debug] [JSONWP Proxy] Got response with status 200: \"{\\n  \\\"value\\\" : {\\n\\n  },\\n  \\\"sessionId\\\" : \\\"334D0B8A-6B9E-4BAA-9BDA-BFEE66EBB584\\\",\\n  \\\"status\\\" : 0\\n}\"\n[debug] [XCUITest] Not clearing log files. Use `clearSystemFiles` capability to turn on.\n[debug] [iOSLog] Stopping iOS log capture\n[debug] [BaseDriver] Event 'quitSessionFinished' logged at 1516514455352 (14:00:55 GMT+0800 (CST))\n[debug] [MJSONWP] Received response: null\n[debug] [MJSONWP] But deleting session, so not returning\n[debug] [MJSONWP] Responding to client with driver.deleteSession() result: null\n[HTTP] <-- DELETE /wd/hub/session/5469f63c-9b2b-4a3a-bbdb-fa26bd6315f9 200 231 ms - 76\n\n```","tags":["Appium"]},{"title":"Appium源码目录说明","url":"/2018/01/29/201801291522/","content":"Appium版本 1.7.2\nAppium源码主要由appium的入口文件js及一些引用的基础类库组成，以下举例说明源码目录大致功能，对于类库以appium-base-driver为例，类库中源码整体结构基本一致。\n#### appium文件夹下内容\n\n```\n├── AUTHORS\n├── CHANGELOG.md\n├── CONDUCT.md\n├── CONTRIBUTING.md\n├── GOVERNANCE.md\n├── IDEAS.md\n├── LICENSE\n├── README.md\n├── RELEASE.pdf\n├── ROADMAP.md\n├── build//打包后生成的文件夹\n├── node_modules//引用的类库文件夹\n├── docs//文档文件夹\n├── commands-yml//文档相关文件夹\n├── bin\n│   └── ios-webkit-debug-proxy-launcher.js\n├── gulpfile.js//程度打包文件\n├── lib//主程序执行入口\n│   ├── appium.js //\n│   ├── config.js//基础配置相关\n│   ├── grid-register.js\n│   ├── logger.js//日志\n│   ├── logsink.js//日志\n│   ├── main.js //程序执行入口\n│   ├── parser.js //appium终端命令相关js\n│   └── utils.js//基础类库\n├── npm-shrinkwrap.json\n├── package.json\n├── packweb.json\n└── triagers.json\n```\n#### 基础类库appium-base-driver\n```\n├── LICENSE\n├── README.md\n├── build//打包后生成的文件夹\n├── node_modules//引用的类库文件夹\n├── docs//文档文件夹\n├── gulpfile.js//gulp打包文件\n├── index.js//程序入口\n├── lib//主要执行代码文件夹\n│   ├── basedriver\n│   │   ├── README.md\n│   │   ├── capabilities.js//配置文件\n│   │   ├── commands\n│   │   │   ├── find.js\n│   │   │   ├── index.js\n│   │   │   ├── session.js//客户端与服务端创建sessionId\n│   │   │   ├── settings.js\n│   │   │   └── timeout.js\n│   │   ├── desired-caps.js\n│   │   ├── device-settings.js\n│   │   ├── driver.js//基础类库\n│   │   ├── helpers.js\n│   │   └── logger.js\n│   ├── express\n│   │   ├── README.md\n│   │   ├── crash.js\n│   │   ├── express-logging.js\n│   │   ├── logger.js\n│   │   ├── middleware.js//中间件\n│   │   ├── server.js//appium服务启动\n│   │   └── static.js\n│   ├── jsonwp-proxy\n│   │   ├── README.md\n│   │   └── proxy.js//服务端与设备端通信\n│   ├── jsonwp-status\n│   │   ├── README.md\n│   │   └── status.js//遵循json wire protocal的code返回值 \n│   └── mjsonwp\n│       ├── README.md\n│       ├── errors.js\n│       ├── helper.js\n│       ├── index.js\n│       ├── mjsonwp.js//接收客户端res并返回res\n│       ├── routes.js//路由配置\n│       ├── validators.js//参数验证\n├── package-lock.json\n├── package.json\n├── static//静态资源\n└── test//测试用例\n```","tags":["Appium"]},{"title":"基于源码分析Appium服务端启动过程","url":"/2018/01/18/201801182037/","content":"#### 写在前面\n\n本文档主要是通过断点跟踪对于Appium源码，从而记录的Appium服务端的启动过程，如有错误或者理解不当之处，欢迎评论提出。\nAppium版本：1.7.2 客户端  appium-python-client  2018年1月\n可以直接看结论，根据结论中的关键js文件即可断点跟踪出全过程。\n\n#### appium文档\n\n[github](https://github.com/appium)\n\n[官方网站](http://appium.io/)\n\n### 主体结构\n\n![官方图片](http://upload-images.jianshu.io/upload_images/1094385-50476463c0d726b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n首先是官方这张图片，这张图片简直涵盖appium所有知识点！而且对于这张图片还有中文的readme！\n[中文readme直通车](https://github.com/appium/appium/blob/master/docs/cn/contributing-to-appium/appium-packages.md)  \n图上分类很清晰 基本上以appium为前缀的都被封装成了类库，通过npm加载，在node_modules中如下图所示，其中appium-base-driver为整个服务的基础类库。上图所示的 `jsonwp-proxy`、`mobile-json-wire-protocal`等都在里面。\n![image.png](http://upload-images.jianshu.io/upload_images/1094385-aba2f76c6e89ea0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### node的express\nappium的服务端采用的是express框架，[express中文文档](http://www.expressjs.com.cn/)，如果之前用express建立过项目的话，会对express中的路由比较熟悉，很多时候路由的处理大概像[Appium源码分析(3)-路由器模块](http://blog.csdn.net/itfootball/article/details/44707431)这样列出来的样子，即通过`rest.get('/wd/hub/status', controller.getStatus);`该种方式可以查看到所有路由的处理，但是到今年18年appium的代码它的路由配置经过了层层调用。\n\n而且作为node服务之前比较习惯入口的app.js即作为服务开启，但是在appium中它将该入口作为express模块直接放在了`appium-base-driver`中，也就是说appium源码的main入口并不是服务入口，那么他们之间的关系是一个怎样的继承及调用呢？\n\n### 源码目录分析\n假设我们想实现一个与客户端通讯的服务，那么主要包括服务开启、客户端http请求，响应函数，那么在appium中我们将其细化一下，大概是\n>开启服务->客户端传来请求->开启当前测试用例会话->根据配置确定ios、android等->分别处理ios或安卓请求->ios或安卓返回后->响应客户端吧->关闭会话。\n\n首先看入口结构：\n\n![WX20180118-194031.png](http://upload-images.jianshu.io/upload_images/1094385-3dfc475124e93591.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n* build工程打包后出现的文件 程序执行来源于build中的main.js ,基本是对lib文件夹下通过babel对于代码进行的转换，所以调试的时候建议根据main.js调试\n* config.js 配置文件\n* logger.js 日志处理\n* parser.js 终端命令的处理\n* utils.js 基础函数\nmain.js 中除了启动的一些检查，重点代码在于\n```\nimport { server as baseServer } from 'appium-base-driver';\nlet router = getAppiumRouter(args);//该函数来源于appium.js\n  //此处router返回的是个函数  用于装填路由路径 该函数执行路径位于/mjsonwp/mjsonwp.js 中routeConfiguringFunction 的返回函数\n  //baseServer执行之后服务开始启动\nlet server = await baseServer(router, args.port, args.address);\n```\n这两行代码可nb厉害了……就这两行基本就把基础类库溜了一圈！代码都是几行几行的，然后一调就转一大圈\n在appium.js中我们找到了以下函数\n```\nimport { BaseDriver, routeConfiguringFunction, errors,\n         isSessionCommand, processCapabilities } from 'appium-base-driver';\n\nfunction getAppiumRouter (args) {\n  let appium = new AppiumDriver(args);//实例化的这个类继承了appium-base-driver！\n  return routeConfiguringFunction(appium);//这个函数来自于appium-base-driver \n}\n```\n由此成功引入基础类库`appium-base-driver`，然后就去那里翻吧\n#### 基础类库appium-base-driver\n![没截全的地方都是配置](http://upload-images.jianshu.io/upload_images/1094385-7201454a76fa3ac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n画出的几个红框基本就是代码功能分类，其中`jsonwp-proxy`和`mjsonwp`是和协议相关，由于我不是很了解，所以不做介绍，只说明其中代码位置。\n上边提到代码转向`routeConfiguringFunction `\n\n#### routeConfiguringFunction\n这出自`mjsonwp/mjsonwp.js`，**请牢牢的记住这个返回函数！！！**\n```\nfunction routeConfiguringFunction (driver) {\n//...省略一些\n  // return a function which will add all the routes to the driver\n  return function (app) {\n    for (let [path, methods] of _.toPairs(METHOD_MAP)) {\n      for (let [method, spec] of _.toPairs(methods)) {\n        // set up the express route handler\n        buildHandler(app, method, path, spec, driver, isSessionCommand(spec.command));\n      }\n    }\n  };\n}\n```\n它返回了一个函数并且里面还传参了`app`,之前断点打到这里时满脑子都是**我是谁，我在哪里，我要干什么**\n我们把代码往上看一下`routeConfiguringFunction`的返回值返回给`getAppiumRouter `再返回给let router  然后再传给baseServer（怪我不好好学js……看个代码艰辛非常……）\n那么baseServer来自哪里呢？看import，它来自appium-base-server!\n**main.js中调用了一圈再次进入appium-base-server**\n\n#### express中的server.js\n之前说到要去找baseServer来自哪里，终于在express/server.js中找到了  就是appium的http服务启动的地方！所以说服务开启的地方不在外部！在基础类库里啊！\n```\nasync function server (configureRoutes, port, hostname = null) {\n//......\n//里面有这样的代码\nconfigureServer (app, configureRoutes) {\n//然后再该函数中调用了\n  configureRoutes(app);\n}\n```\n所以代码走到这里执行的就是那个返回函数，app是express的实例！那么执行这一步是为了做什么呢？这个`METHOD_MAP`是最大的全路由配置！来自于`mjsonwp/routes.js`,其中500行都是路由配置，经过该配置有效避免批量写`app.get()//balabala`\n```\n\nfunction (app) {\n  for (let [path, methods] of _.toPairs(METHOD_MAP)) {\n  //balabalbala\n }\n```\n至此全路由配置装填结束！\n\n#### 服务启动\n这个就没有什么波折了，既然server.js都找到了，就再这个文件中,看到这里终于看到了熟悉的node启动~\n```\nlet app = express();\nlet httpServer = http.createServer(app);\n```\n当断点跟到这里时终端就可以跳出如下输出,服务启动啦~\n```\n[Appium] Appium REST http interface listener started on 0.0.0.0:4723\n```\n### 总结\n\n启动服务执行过程\n`lib/main.js` 执行来自于`lib/appium.js`中的`getAppiumRouter`函数\n该函数中实例化`AppiumDriver`类，同时读取路由配置文件，该类继承于`Appium-base-driver`库中暴露的基类，路由配置文件来源于`Appium-base-driver`库中`/mjsonwp/routes.js`的配置\n配置文件读取之后在`/mjsonwp/mjsonwp.js`中以函数的形式返回`main.js ` 执行`baseServer`函数  该函数来自于`Appium-base-driver/express/server.js`\n\n也就是说整个过程从\n>main.js-[调用]-appium.js-[调用]-appium-base-driver/mjsonwp-[返回]-main.js-[调用]-appium-base-driver/express\n\n其实是通过层层调用将路由已配置的方式进行装填并在基础类库`appium-base-server`中启动\n\n\n\n","tags":["Appium"]},{"title":"关于Appium在安卓上频繁安装unlock、setting.apk的问题查找记录","url":"/2018/01/18/201801181414/","content":"\n\n#### 总结\n\n该问题已经被官方在1.7.x的版本中进行修复。以下为对于该问题的查找记录\n#### 1.6.x版本说明\n\n在appium1.6.x版本中 每次进行安卓用例测试时 appium都会安装unlock.app、setting.app、ime.app\n\n关于这个的解决方式可参考如下blog\n\n[appium解决每次运行都需要安装Unlock以及AppiumSetting的问题](http://blog.csdn.net/hszxd479946/article/details/78900982)\n\n或者在appium设计到该处问题的源码位置，将其添加判断以上app是否安装的逻辑即可\n\n#### 1.7.x版本说明\n当前npm版本为1.7.2版本，官方已经修复了这个问题，在1.7.2的[changeLog](https://github.com/appium/appium/blob/master/CHANGELOG.md)中说明如下：\n![image.png](http://upload-images.jianshu.io/upload_images/1094385-b33ef73da19de461.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240);\n\n由于这个问题设计到的代码在appium-android-driver这个封装好的组件中，所以具体看一下是什么时候更改的,是在17年10月份的这次代码提交中修复了该问题。\n\n从commit继续往下看，9月份这里也进行过改动，但是10月份改动之后与当前npm版本是一致的。\n[Fix handling of settings and unlock app pushing](https://github.com/appium/appium-android-driver/commit/033b70e75fcada83ff2e73e99d9c605c59b35621)\n![image.png](http://upload-images.jianshu.io/upload_images/1094385-8827acf34ec14ae1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n对于installOrUpgrade这个函数，它的定义在封装好的android-adb类库里面，那么接下来去这里看一下对于这个函数的更改。\n\n[android-adb commit](https://github.com/appium/appium-adb/commit/404455cf43e1f0086fa30d1ff6675f216f2e5a73)\n\n这个函数同样进行了两次更改，在9月份的更改中采用了外部传参的方式判断是否安装但是在10月份的commit中又去掉了外部传参的参数，改为在该函数中判断是否安装\n\n![image.png](http://upload-images.jianshu.io/upload_images/1094385-c070ef3ec671314c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**对于这个的总结就是该问题已经被官方在1.7.x的版本中进行修复。**\n**2018年1月**","tags":["Appium"]},{"title":"使用Tesseract+python进行图片转文字记录","url":"/2018/01/14/201801040223/","content":"#### 背景说明\n\n该blog完成于18年1月\n\n先把Tesseract的基础部分放上来。\n\n由于对游戏的文案非常感兴趣，所以希望可以将游戏中图片截图，识别图片上的文字转成txt，基于此记录一下学习过程，简单记录。\n#### 环境说明：\n\nMac 10.13\n\npython 2.7\n\nTesseract 3.05.01[github地址](https://github.com/tesseract-ocr/tesseract/wiki)\n\n因为对这些也不懂所以都是按照网上的教程来得\n#### 英文识别\n`Tesseract`github有安装教程。相关API参照[Python:文本识别抛弃pytesser，直接使用Tesseract\n](https://www.polarxiong.com/archives/python-pytesser-tesseract.html)，也就是说，当安装好后Tesseract之后，可以在终端直接操作\n\n主要命令操作：\n```\ntesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]\n\ntesseract    图片名  输出文件名 -l 字库文件 -psm pagesegmode 配置文件\n\n-l后的字库文件可以切换为中文，默认是英文\n-psm是对于识别模式的一些设置\n\n```\n按照wiki的说法\n```\ntesseract 图片路径   输出文件名//eg:tesseract x.png out\n```\n即可在终端对应目录下输出out.txt 里面是对文字的识别，按照如上试了以下两张图片\n![test.jpg](http://upload-images.jianshu.io/upload_images/1094385-8fd43d8b9135462e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这张图片的识别结果未成功，并未生产任何txt文件，终端报错如下\n```\nTesseract Open Source OCR Engine v3.05.01 with Leptonica\nWarning. Invalid resolution 0 dpi. Using 70 instead.\n//关于为什么会报这一行还没有查明白，因为发现无论成功与否都会报这一行\n//简单搜索一下大概于tif什么之类的有关系，还没有查找\n```\n当换成另一张图片![4979037-c4469cd2356e5a06.jpg](http://upload-images.jianshu.io/upload_images/1094385-4c0919c8b4b2228b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n识别且产生txt，内容如下\n```\nY\" ‘ WWIHBNEISM H8 3\n\nORGAN\nNICHOLSON FREEMAN\nMUM’VHHIIV-HUN’N/DﬂmhnAMENUMMME UWUFDW WM TIFEUEKEMT A\n¢ WWW!“ HUBEEWWMWFW .\nzzrmmn Jmmmu JWMHH ‘ ,\nmum _. v _ mm“\nnow\n\n```\n从以上看出，识别还是要看图片背景等，在tesseract总默认是英文识别，且涉及到参数psm的问题，关于参数psm请在终端直接输入`tesseract`\n```\nPage segmentation modes:\n  0    Orientation and script detection (OSD) only.\n  1    Automatic page segmentation with OSD.\n  2    Automatic page segmentation, but no OSD, or OCR.\n  3    Fully automatic page segmentation, but no OSD. (Default)\n  4    Assume a single column of text of variable sizes.\n  5    Assume a single uniform block of vertically aligned text.\n  6    Assume a single uniform block of text.\n  7    Treat the image as a single text line.\n  8    Treat the image as a single word.\n  9    Treat the image as a single word in a circle.\n 10    Treat the image as a single character.\n 11    Sparse text. Find as much text as possible in no particular order.\n 12    Sparse text with OSD.\n 13    Raw line. Treat the image as a single text line,\n\t\t\tbypassing hacks that are Tesseract-specific.\n```\n初步的文字识别还是ok的，因为最终要的结果是中文识别，所以要看一下如何进行中文识别。\n#### 中文识别\ntesseract提供了中文的文字识别，下载地址[https://github.com/daheicode/chi_sim](https://github.com/daheicode/chi_sim)\n下载之后将`chi_sim.traineddata`文件拷贝到中文文件存放地址：\n```\n/usr/local/Cellar/tesseract/3.05.01/share/tessdata\n//我在mac上存放到这里时有效的，如果无效就需要再查查了\n//这个文件进去后可以看到英文的识别文件`eng.traineddata`）\n```\n开启终端进行中文文字识别\n```\ntesseract 输入图片路径 -l chi_sim 输出文件名字\n```\n这里测试了一下，识别结果一言难尽吧，对于阴阳师的传记识别很差，周围有一些文字进行干扰\n![图片j](http://upload-images.jianshu.io/upload_images/1094385-3df4b477c29797e8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n如果对于图片进行裁剪到如下程度![x.jpeg](http://upload-images.jianshu.io/upload_images/1094385-ac6362b56cdf2e5e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n识别结果是很一言难尽的，。这个结果的误差率挺高的。\n```\n待1己二 lw\n\n桢言宛一次出现耱诀盯町倪 衅\n也只是笑笑、 并没有责怪这个骧子\nD 但是幔憧地. 贵怪也开始了' 篷\n篝还有打骂. 骥子的靴上遍布伤痕\n\n害怕受列惩罚的孩子. 哭*预知著\n一切. 预言却还是耧未趟不准口\n终于. 有人操乱 这孜子既然己经\n失去T倾知的能九 不如就放弄这\n个孩子, 将他献给淹礼 或许还能\n平息灾祝 纂一次听到这个提议时.\n人4ﬂ纷汾反对, 认为这对璩子太瀵\n忍了口 可是巢二炎 第三次的时伉\n反对的人罐毅赭叽\n\n```\n尝试了一下微博的截图\n![t.png](http://upload-images.jianshu.io/upload_images/1094385-b995d45c3ada0e1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n结果为\n```\n全球健身中心-喧\n11分钟前来目 微博淝伽咖\n拿去参考-下0\n\n@全球装饰大全 - 甜\n我敢说这是我见过最漂亮最实用的室内设计了,绝对没有比这更简美了.迸门就是原木地板,\n客厅就简单的布艺沙发搭配原木电器柜.迸门两边做的是嵌入式柜体,牧纳更是做到了极致;\n住在这样纯夫然酌冢里简直不要不要的m 喜欢就关注@全球装饰大全 胗微博全景图片\n\n〕\n\n微博全景图片\n我敢说这是我见过最室内设计了, 绝对没有比这更简美了° 布艺沙发\n搭配原木电器柜° 迸门两边做的是嵌入式柜体, 底面整体原木地板,\n\n12分钟前 来自 微博 weibo.oom 区 97 臼 6 凸 35\n\n```\n到这里看一下我自己的需求是可以将图片中的文字转换，而且需求图片没有阴阳师背景那么杂乱，所以转换结果很好，因此没有继续看如何提高识别准确度。\n这里一直讲的是通过终端进行图片转文字。但其实最后是通过python调用的Tesseract\n\n#### 未完待续\n未完待续\npython控制安卓截图=>截图后裁图到合适区域=》图片转换文字存储=》模拟点击进行下一页面  【循环此过程】\n（循环过程还没写 程序大概就是借鉴跳一跳的那个来~~~毕竟还不会python……）\n\n#### 后续添加\n现在在18年的6月把这个补一下后续，关于识别游戏中的文案，采用了python控制安卓截图，但是再图片转换文字的时候调用了百度开放的图片转文字接口，每天免费500次，精确度非常高~整理起来特别爽~\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Python"]},{"title":"基于Appium+WDA+Python搭建IOS自动化测试全纪录(三):真机demo运行","url":"/2018/01/10/201801102318/","content":"\n\n\n#### 前期回顾：\n[基于Appium+WDA+Python搭建IOS自动化测试全纪录(一):环境搭建](2018/01/10/201801102040/)\n\n[基于Appium+WDA+Python搭建IOS自动化测试全纪录(二):模拟器demo运行](2018/01/10/201801102318/)\n\n在模拟器将demo跑通之后，就要在真机上测试啦，模拟器总是要为真机服务的。\n#### 证书问题\n在真机上主要是涉及到签名及证书的问题详解见如下blog\n[iOS App 签名的原理](http://blog.cnbang.net/tech/3386/)\n\n主要在此简单记录一下证书的配置吧。\n\n在xcode中找到build Setting配置部分（之所以把这张图放出来是因为我最开始找不到这个配置，萌新啥都找不到）：\n![WX20180115-203847@2x.png](http://upload-images.jianshu.io/upload_images/1094385-1ad7fd8414daedc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n更改一下三个字段对应的内容：\n Code Siging identify  证书里面对应的开发者\nProduct Bundle Identify  对应的bundleID\nProvisioning Profile    包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。\n数据包是.mobileprovision文件格式结尾  在终端中输入如下命令即可看到里面的信息\n\n```\nsecurity cms -D -i xxxxx.mobileprovision\n```\n\n改完之后 我们开发的程度就可以装到真机上啦，这个时候选择在真机上运行，就可以啦。\n\n#### Appium中wda真机配置\n\n测试app装到真机上之后，还要考虑如何开启py脚本，在真机上进行测试。\n这里需要注意两点：\n* webDriverAgent的配置\n* py脚本的配置有变化\n\n关于WebDriverAgent[github地址](https://github.com/facebook/WebDriverAgent)这个还没了解太多，所以在这里先不介绍了。简单来说appium的服务中带有webDriverAgent，在模拟器上我们开启appium服务，会发现模拟机上会同步装上WebRriverAgentRunner的app，这个是appium能在ios上测试的关键条件，但是在真机上，却不能直接装上。\n**因为需要证书啊！！！**\n\n不能直接从github上下载进行证书配置，要改appium中node_modules中的webDriverAgent。\n\n先找到appium的位置 \n```\nfind / -name appium   // /usr/local/lib/node_modules/appium \n```\n\n最后找到的地址大概如下：\n```\n/usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgent\n```\n\n放到xcode中进行签名证书配置，注意虽然我们打开的是WebDriverAgent文件夹，但是我们要配置的是WebdDriverAgentRunner  在其Build Settings中进行与证书有关的配置\n```\nCode Siging identify  证书里面对应的开发者\nProduct Bundle Identify  对应的bundleID\nProvisioning Profile    包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。\n```\n配置完毕后还需要再WebdDriverAgentRunner中添加一个RoutingHTTPServer.frameork\n![WX20180115-222415@2x.png](http://upload-images.jianshu.io/upload_images/1094385-8559492188f853ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n点击添加之后->add Other\n在如下路径可以查找到该framework\n```\n/usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgent/Carthage/Build/iOS\n```\n找的一定是appium文件路径下的！上边关于wda并没有做过多说明，因为还不怎么了解~等了解了再补充相关知识~\n\n#### py脚本\npy脚本主要是配置有更改，主体文件请见开头（二）模拟器demod的blog\n在真机上配置更改如下：\n```\n desired_capabilities={\n                'bundleId': //这个是和证书有关联的\n                'platformName': 'iOS',\n                'platformVersion': '9.3.2',\n                'deviceName': 'iPhone5 slave15',\n                'automationName':'XCUITest',\n                \"clearSystemFiles\" : True,\n                'udid'://模拟器的时候我们用uuid，但是真机上请用udid\n            })\n```\n然后启动appium 发现真机上装上了厕所app 装上了WebDriverAgentRunner   然后用python运行脚本就ok拉！\n\n\n以上为从搭建环境-》模拟器跑demo-》真机跑demo的简单记录，不涉及到原理方面的讲解，如有错误之处还请提出。\n\n\n[Tbc]\n\n","tags":["Appium环境搭建"]},{"title":"基于Appium+WDA+Python搭建IOS自动化测试全纪录(二):模拟器demo运行","url":"/2018/01/10/201801102224/","content":"\n[基于Appium+WDA+Python搭建IOS自动化测试全纪录(一):环境搭建\n](2018/01/10/201801102040/)\n\n由于在跑这个demo之前，完全没有接触过移动端，就是连模拟器都不会启动的那种，所以步骤会说的比较啰嗦详细。\n\n#### 如何跑测试DEMO\n\n选定测试用例,github提供了测试的explame\n\n[https://github.com/appium/sample-code](https://github.com/appium/sample-code)\n\n#### 代码选择\n\n需要选择一个ios的APP，一个python脚本，如图选择的是app里面的TestApp，脚本选择的是python里面的ios_sample.py\n![image.png](http://upload-images.jianshu.io/upload_images/1094385-72611e445351abec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240);\n\n#### 模拟器运行\n\n因为是在模拟器上运行，所以要先把app放到模拟器上。一般来说通过在xcode中运行代码就可在模拟器中生产app，但是这个TestApp用例进去看了之后发现里面如图所示：\n![image.png](http://upload-images.jianshu.io/upload_images/1094385-9a55f95dc9c13a23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以就只能开启模拟器，然后把右边红框框生产的app拖放到模拟器里。\n想用命令行操作请看这里：[iOS-通过命令行安装.app到模拟器https://www.jianshu.com/p/8edf0b4ffb1b](https://www.jianshu.com/p/8edf0b4ffb1b)\n\n#### 配置更改\n\n现在app已经拖到模拟器里了，接下来启动python脚本，在执行脚本之前，还有一些配置需要更改。\n如下图所示，\n![WX20180110-205552@2x.png](http://upload-images.jianshu.io/upload_images/1094385-09190b669d9db567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n首先说uuid的问题，每一个模拟器都有对应的uuid，这里在执行模拟器时用的是uuid，但是到了真机上，就变成了udid。\n\n**所以要拿到当前模拟器的uuid：**\n\n终端输入命令可得到想要的模拟器的字符串。\n```\ninstruments -s devices\n```\n![image.png](http://upload-images.jianshu.io/upload_images/1094385-b0756ac60e6e89f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以配置信息多添加一行\n```\n  'uuid':'xxxxxx'\n```\n\n更改后的配置如下：\n```\n          desired_capabilities={\n                'app': app,\n                'platformName': 'iOS',\n                'platformVersion': '11.2',//更改为当前模拟器的版本\n                'deviceName': 'iPhone 6s',//更改为当前模拟器的型号 \n                'uuid':'2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5'//更改为当前模拟器的uuid\n//经过测试发现在模拟器上uuid不是必须的，所以这里不填也可正常运行\n            })\n\n```\n#### 启动脚本\n先启动appium\n```\nappium\n```\n当控制台中显示如下，启动成功\n```\n[Appium] Welcome to Appium v1.7.2\n[Appium] Appium REST http interface listener started on 0.0.0.0:4723\n```\n\n\n\n在脚本所在目录下执行\n```\npython xxxx.py\n```\n（由于ios_sample.py的名字被用来测试别的了，所以给其改成了ios.py）\n![image.png](http://upload-images.jianshu.io/upload_images/1094385-9cbb164e39d74e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如此，模拟器上测试demo运行成功！\n由于是在整个流程跑通之后回头做的纪录，所以可能有些地方纪录不完善，错误之处欢迎提出。\n\n------\n[Tbc]\n\n\n\n\n\n\n\n","tags":["Appium环境搭建"]},{"title":"基于Appium+WDA+Python搭建IOS自动化测试全纪录(一):环境搭建","url":"/2018/01/10/201801102040/","content":"\n#### 写在前面\n计划将整个自动化搭建过程全部纪录一下，从环境搭建到模拟器跑demo，到真机跑demo  \n\n当前测试及环境跑通日期为2018.1月\n\n**本文要点:**\n* appium ios环境搭建  python环境搭建\n* Mac下 appium 1.7.2  python 2.7\n\n#### appium环境搭建\n* 安装Xcode，安装xcode-command-line-tools\n```\n终端中输入以下命令：xcode-select --install \n```\n* 安装brew\n\n    [官网地址](https://brew.sh/)\n\n    终端中输入\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n* 安装libimobiledevice\n```\nbrew install libimobiledevice --HEAD \n```\n* 安装carthage\n```\nbrew install carthage\n```\n* 安装node [官方的地址](https://nodejs.org/en/download/) 下载.pkg文件安装\n\n* 安装cnpm\n\n安装cnpm(由于某种原因,直接用npm下载安装会有好多网络问题，安装淘宝的cnpm要比npm好用)https://npm.taobao.org/\n\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n* 安装ios-deploy\n```\ncnpm install -g ios-deploy\n```\n* 安装xcpretty\n```\ngem install xcpretty\n```\n* 安装java环境\n\n(1)下载JAVA安装包：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n\n(2)配置JAVA_HOME环境：\n\n在~/.bash_profile\n\n修改如下：\n```\n\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home   \n\nexport PATH=$JAVA_HOME/bin:$PATH \n\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n```\n* 安装appium，appium-doctor\n\n如果cnpm也卡了，想办法连vpn~\n```\ncnpm install -g appium\ncnpm install -g appium-doctor\n```\n这之后执行appium-doctor\n如果ios部分都变绿了就ok了。其中Android_Home,adb之类的变红是安卓的环境，对于ios没有什么影响。如果报错缺少了哪里的安装，直接搜安装方法就好。\n![image.png](http://upload-images.jianshu.io/upload_images/1094385-fec7f2f94bbfc472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### Python环境搭建\n\n由于采用Python来写自动化测试脚本，因此需要搭建Python的相关环境\n\n采用了Python 2.7\n\n使用pip方式安装\n```\nbrew install pip\npip install lxml\n```\n安装Python-client\n```\npip install Appium-Python-Client\n```\n搭建或者运行过程中出现xxx not defined  之类的，可能是模块缺失，查一下是哪些模块  补一下就好，由于是在整个流程跑通之后回头做的纪录，所以可能有些地方纪录不完善，错误之处欢迎提出。\n\n那么环境搭建之后，通过启动app跑脚本即可达到流程跑通，所以接下来说如何跑脚本。\n\n----\n[Tbc]\n\n\n\n\n\n\n\n\n \n\n\n","tags":["Appium环境搭建"]},{"title":"Python爬取B站弹幕+R语言分词安装调试报错记录","url":"/2017/09/03/201709031632/","content":"\n**环境说明：\nwindows8.1 x64+python3.6+scrapy1.4\nwindow8.1 x64+R3.4.2+jiebaR插件+rJson插件+RStudio编辑器+wordcloud2插件**\n\n### 写在前面\n\n以下所有问题答案均来源网络，在此整理并做记录。本文记录源于[萌新学习Python爬取B站弹幕+R语言分词demo说明](2017/09/03/201709031514/)\n建议结合食用，风味更佳\n\n### python部分\n#### python安装过程中出现了当前程序已停止安装\n这个忘记截图了，就是在安装exe的过程中出现报错，安装成功后无法打开。后来查找到原因据说是进入python官网直接下的windows版本是32位的，当我找到64位时下载再安装就正常了。\n\n#### scrapy安装过程中报错`Microsoft Visual C++ 14.0 is required.`\nscrapy安装过程中报错如下：\n```\n building 'twisted.test.raiser' extension\n error: Microsoft Visual C++ 14.0 is required. Get it with \"Microsoft Visual C++ Build Tools\": http://landinghub.visualstudio.com/visual-cpp-build-tools\n```\n![](http://upload-images.jianshu.io/upload_images/1094385-167a042f16403743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**解决方式**\n[http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted](http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted) \n下载***twisted***对应版本的whl文件（如我的`Twisted‑17.5.0‑cp36‑cp36m‑win_amd64.wh`l，cp后面是python版本，amd64代表64位，运行命令：\n```\npip install E:\\Twisted-17.5.0-cp36-cp36m-win_amd64.whl\n```\n然后再次执行 \n```\npip install Scrapy\n```\n#### scrapy启动demo过程中报`ModuleNotFoundError: No module named 'win32api'`\nhttps://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/\n去这个网站下载对应的win32的软件\n\n![](http://upload-images.jianshu.io/upload_images/1094385-e4dd1fbbe58ecbf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 安装win32的时候报错如下\n\n```\nPython version 3.6 required, which was not found in the registry\n```\n![](http://upload-images.jianshu.io/upload_images/1094385-8b4a64231b55d8a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这个网上说是没有注册的问题，在网上找了一段代码\n```\nfrom __future__ import print_function\n \n \nimport sys\n \ntry:\n    from winreg import *\nexcept ImportError:\n    from _winreg import *\n \n# tweak as necessary\nversion = sys.version[:3]\ninstallpath = sys.prefix\n \nregpath = \"SOFTWARE\\\\Python\\\\Pythoncore\\\\{0}\\\\\".format(version)\ninstallkey = \"InstallPath\"\npythonkey = \"PythonPath\"\npythonpath = \"{0};{1}\\\\Lib\\\\;{2}\\\\DLLs\\\\\".format(\n    installpath, installpath, installpath)\n \n \ndef RegisterPy():\n    try:\n        reg = OpenKey(HKEY_CURRENT_USER, regpath)\n    except EnvironmentError as e:\n        try:\n            reg = CreateKey(HKEY_CURRENT_USER, regpath)\n            SetValue(reg, installkey, REG_SZ, installpath)\n            SetValue(reg, pythonkey, REG_SZ, pythonpath)\n            CloseKey(reg)\n        except:\n            print(\"*** Unable to register!\")\n            return\n        print(\"--- Python\", version, \"is now registered!\")\n        return\n    if (QueryValue(reg, installkey) == installpath and\n        QueryValue(reg, pythonkey) == pythonpath):\n        CloseKey(reg)\n        print(\"=== Python\", version, \"is already registered!\")\n        return\n    CloseKey(reg)\n    print(\"*** Unable to register!\")\n    print(\"*** You probably have another Python installation!\")\n \nif __name__ == \"__main__\":\n    RegisterPy()\n```\n将代码保存成`register.py`，在该文件夹下执行\n ```\npython register.py\n```\n![](http://upload-images.jianshu.io/upload_images/1094385-86762400ebebee39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n问题解决\n\n### R语言部分\n\n#### 读取文件报错\n```In addition: Warning message:\n   In read.table(\"E:/danmu/2.txt\", header = FALSE, ) :\n   incomplete final line found by readTableHeader on 'E:/danmu/2.txt'\n```\n当时的txt文件时我自己写入的，问题可能出在文件的结尾没有空格上，我在文件的结尾加了空格就可以正常使用了（如果空格也不行，试试回车）\n\n#### 调用wordcloud2函数时报错\n```\nError in `[.data.frame`(data, , 1:2) : undefined columns selected\n```\n这个问题我后来也没有解决，这个问题的上下文是\n```\nkeys = worker(\"keywords\",topn=150)\n re = vector_keywords(segment,keys)\n wordcloud2(re, size = 2, minRotation = -pi/2, maxRotation = -pi/2)\n```\n我这边猜测是jiebaR的`vector_keywords`函数返回的是向量，且输出的结果没有词频，当我把`freq(segment)`的结果传给`wordcloud`时就可以正常执行，此时`freq(segment)`的结果输出类型为`data.frame`，猜测如下：\n1. wordcloud接受的参数类型为data.frame 且需要有词频\n2. wordcloud接受的参数类型不一定为data.frame 但一定需要有词频\n词频是一定需要的，但是参数类型不确定，就因为`vector_keywords`的结果不知道怎么分出词频，才采用了`freq()`函数绘制词云。\n![QQ截图20170903134316.png](http://upload-images.jianshu.io/upload_images/1094385-2097f82d76c53959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n跪求大佬指导如何用关键词绘制词云啊，我真的不知道这个生成的关键词怎么把词频和词分开！而且为什么把`vector_keywords`的结果转换成`list`类型或者`data.frame`类型词频就消失了呢！输出的.csv文件里还是没有词频啊！\n\n\n#### R语言的插件安装的意外顺利，就是360总是要阻止行为\n\nthe end.\n","tags":["Python"]},{"title":"萌新学习Python爬取B站弹幕+R语言分词demo说明","url":"/2017/09/03/201709031514/","content":"## 写在前面\n之前在简书首页看到了Python爬虫的介绍，于是就想着爬取B站弹幕并绘制词云，因此有了这样一个简单的尝试，从搭建环境到跑通demo，不懂语法，不知含义，装好环境，查到API，跑通Demo，就是目标！纯零基础萌新！\n[demo地址](https://github.com/a67c/pyBilibilBarrage)(只有python的demo，R的没有上传)\n\n[关于环境的安装及调试过程中遇到的问题记录请移步](http://www.jianshu.com/p/2f2b92783c5b)\n\n## Python爬取B站弹幕\n### 环境说明\n\n**windows8.1 x64+python3.6+scrapy1.4**\n\n参考文档：\n\n[scrapy github](https://github.com/scrapy/scrapy/blob/1.4/docs/topics/selectors.rst)\n\n[scrapy document](https://doc.scrapy.org/en/latest/topics/selectors.html?highlight=extract)\n\n[scrapy爬虫框架入门实例](http://blog.csdn.net/zjiang1994/article/details/52779537)\n\n### 步骤说明\n\n* 安装python3.6\n* 安装scrapy1.4\n* 建立scrapy demo\n* 跑通demo遇到问题、解决问题\n* 更改demo为B站弹幕爬取demo\n我这边是按照参考文档中 [scrapy爬虫框架入门实例](http://blog.csdn.net/zjiang1994/article/details/52779537)这个demo来做的，这个文章里面无论是介绍还是`scrapy`的入门都非常详细，建议大家按照这个来入门，但是由于慕课网的结构样式以及更改了，所以demo是跑不起来的，因此我换成了爬取B站的弹幕demo。截止2017年9月2日亲测可跑通。\n\n### Demo说明\n**1.  安装scrapy成功之后建立项目`scrapytest`**\n```\nscrapy startproject scrapytest\n```\n**2. demo目录**\n本demo目录仅保留当前demo可用的文件，且文件名字不同于`scrapy`自动生成的文件名字，对于未涉及到的文件进行了删除\n```\n│  scrapy.cfg//项目的配置文件\n└─scrapytest\n    │  CourseItems.py//定义一个容器保存要爬取的数据\n    │  MyPipelines.py//项目中的pipelines文件.\n    │  settings.py//项目中的设置文件.\n    ├─spiders\n    │  │  data.json//爬取数据生成的文件\n    │  └─ Myspider.py//爬虫主代码\n```\n**3. demo代码**\n\n **创建CourseItems.py文件**\n定义一个容器保存要爬取的数据。为了定义常用的输出数据，`Scrapy`提供了`Item`类。`Item`对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like)的API以及用于声明可用字段的简单语法。由于最后输出的只要弹幕的内容，所以容器中只定义了弹幕的内容\n\n```\n#引入文件\nimport scrapy\nclass CourseItem(scrapy.Item):\n    #弹幕内容\n    content = scrapy.Field()\n```\n\n **编写爬取代码Myspider.py**\n* bilibili的弹幕是在xml文件里，每个视频都有其对应的cid和aid，我们取到cid中的数字放入`http://comment.bilibili.com/+cid+.xml`,即可得到该视频对应的cid。\ncid取法：cid在源码中是没有找到的，目前我的做法是在页面上F12，然后查找cid，该cid即为弹幕页的标识，如果有可以通过代码查到的方法，还请告知。目前例子中的cid有1000多条弹幕，建议大家换个少的进行测试。\n\n![cid查找方法](http://upload-images.jianshu.io/upload_images/1094385-e060510f5149b12e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n* 弹幕的xml文件结构非常简单，所以通过Xpath简单解析即可\n\n![弹幕的xml文件结构](http://upload-images.jianshu.io/upload_images/1094385-27d44a81c00fc3cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nimport scrapy\n#引入容器\nfrom scrapytest.CourseItems import CourseItem\n\nclass Myspider(scrapy.Spider):\n    #设置name\n    name = \"Myspider\" //启动项目时所用name\n    #设定域名\n    allowed_domains = [\"bilibili.com\"]\n    #填写爬取地址\n    start_urls = [\"http://comment.bilibili.com/2015358.xml\"]\n    #编写爬取方法\n    def parse(self, response):\n        #实例一个容器保存爬取的信息\n        item = CourseItem()\n        #这部分是爬取部分，使用xpath的方式选择信息，具体方法根据网页结构而定\n        #直接爬取弹幕内容\n        str0 = ''\n        for box in response.xpath('/i/d/text()'):\n            #获取每一条弹幕内容\n            str0 += box.extract()+',';\n            #返回信息\n        item['content'] = str0;//最后输出的结构是值：字符串的结构，详细见输出图\n        yield item\n```\n**编写MyPipelines.py处理数据**\n当成功获取信息后，要进行信息的验证、储存等工作，这里只进行简单的将数据存储在json中的操作。\n```\n#引入文件\nfrom scrapy.exceptions import DropItem\nimport json\n\nclass MyPipeline(object):\n    def __init__(self):\n        #打开文件\n        self.file = open('data.json', 'w', encoding='utf-8')\n    #该方法用于处理数据\n    def process_item(self, item, spider):\n        #读取item中的数据\n        line = json.dumps(dict(item), ensure_ascii=False) + \"\\n\"\n        #写入文件\n        self.file.write(line)\n        #返回item\n        return item\n    #该方法在spider被开启时被调用。\n    def open_spider(self, spider):\n        pass\n    #该方法在spider被关闭时被调用。\n    def close_spider(self, spider):\n        pass\n```\n**注册Pipeline** \n找到`settings.py`文件,这个文件时爬虫的配置文件，在其中添加\n ```\nITEM_PIPELINES = {\n    'scrapytest.MyPipelines.MyPipeline': 300,\n}\n```\n上面的代码用于注册`Pipeline`，其中`scrapytest.MyPipelines.MyPipeline`为你要注册的类，右侧的’300’为该`Pipeline`的优先级，范围1～1000，越小越先执行。(*ps：这个并没有详细了解*)\n**4. 运行demo**\n在`Myspider.py`的同级下执行cmd控制台，运行一下命令。\n```\nscrapy crawl MySpider\n```\n**5. 运行结果**\n这是一个json的文件，json文件的输出结构更改在`Myspider.py`中，我改成这种通过逗号来连接每一条弹幕时是为了之后方便分词。大家也可以把代码改了改成另一种展示方式\n\n![便于分词的展示方式](http://upload-images.jianshu.io/upload_images/1094385-3729642445b03ed2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![另一种方式](http://upload-images.jianshu.io/upload_images/1094385-074555839887ab2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### Python爬取end\n到此python爬取B站弹幕demo结束，接下来我们通过拿到的json文件去R语言中进行分词。\n\n##R语言分词实例\n### 环境说明\n\n**window8.1 x64+R3.4.2+jiebaR插件+rJson插件+RStudio编辑器+wordcloud2插件**\n\n[R语言官网](https://www.r-project.org/)\n\n[Rstudio下载地址](https://www.rstudio.com/products/rstudio/download/)\n\n[R语言中文分司包jiabaR](http://blog.fens.me/r-word-jiebar/)\n\n[R和json的傻瓜式编程](http://blog.fens.me/r-json-rjson/)\n\n[R语言w3c教程](https://www.w3cschool.cn/r/r_overview.html)\n\n[jiebaR中午分词文档](http://qinwenfeng.com/jiebaR/section-1-1.html)\n\n[wordcloud2 gtihub](https://github.com/Lchiffon/wordcloud2)\n\n[R语言︱文本挖掘——词云wordcloud2包](http://www.cnblogs.com/nxld/p/6344233.html?utm_source=itdadao&utm_medium=referral)\n\n### 步骤说明\n* 安装R、Rstudio、jiebaR、rJSON\n* 引入JSON文件\n* 分词处理\n* 停止词处理\n* 过滤数字及字母\n* 产生数据\n* 调用wordcloud2绘制词云\n关于`jiebaR`分词基本是按照[R语言中文分司包jiabaR](http://blog.fens.me/r-word-jiebar/)这个博客的demo来进行的。该博文中对于`jiebaR`的各种函数介绍的非常全面，因此下面demo将不对代码内容进行详细介绍。demo中的各种路径请自行更改。\n\n### demo说明\n只有一个jiebaR.R文件即完成了分词和绘制词云，代码如下：\n```\n#调入分词的库\nlibrary(\"jiebaR\")\nlibrary(\"rjson\")\n\n#这里读取的`python`爬取的`json`文件，拿道了对象中`content`键的值，该值是一长串字符串，在爬虫输出的时候通过逗号来连接字符串，因此分词时是通过逗号进行的分词\nmyfile<-fromJSON(file = \"F:/gitlab/py/scrapytest/scrapytest/spiders/data.json\")$content\n\n#预处理，这步可以将读入的文本转换为可以分词的字符，本demo通过逗号进行分词\n myfile.res<-myfile[myfile!=\",\"]\n\n#调用分词引擎worker函数  stop_word为停止词设置\nwk = worker(stop_word ='F:/R/stopw.txt')\n\n#segment为分词结果\nsegment = wk[myfile.res]\n\n#对于分词结果进行正则过滤，去掉数字及字母\nsegment = gsub(\"[a-zA-Z\\\\/\\\\.0-9]+\",\"\",segment)\n\n#计算词频，该data即为传入词云的数据\ndata <- freq(segment)\n\n#引入wordcloud2，在引入之前请先安装\n library(wordcloud2)  \n\n#调用wordcloud2函数绘制词云，该函数参数在github已有介绍\n  wordcloud2(data,size = 1, fontFamily = \"微软雅黑\",color = \"random-light\"\")\n\n```\n\n![计算词频后的结果](http://upload-images.jianshu.io/upload_images/1094385-9024949a3137c79c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![我一开始万万没有想到我分出来会这么丑](http://upload-images.jianshu.io/upload_images/1094385-f9d22e28a612a9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 问题说明\n\n**1.计算词频**\n\n由于弹幕的条数比较多，分词过滤后的词频很多，没有细查找如何再进一步的排序过滤筛选词，所以导致词云的结果并不是很好\n\n**2. 关键词提取**\n\n个人认为通过关键字提取出的词云会更好一旦，`jiabaR`提供了关键字提取的方法及提取的结果，结果上面是词语出现频率。\n\n```\n#提取150个关键字\nkeys = worker(\"keywords\",topn=150)\n#关键字结果\nre = vector_keywords(segment,keys)\n```\n![提取出的关键字结果](http://upload-images.jianshu.io/upload_images/1094385-d6d5dae7d30132e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n从图上可以看出这个关键词比较适合用来做词云，但是这里遇到了问题，关键字的结果时`vector`类型，并不能直接作为`wordcloud`的参数，从测试结果上来看`wordcloud`的参数接收`data.frame`类型，且要有词的内容和词频，当我通过如下代码将`vector`类型转换为`data.frame`时，并将结果输出到了`csv`的文件后发现，输出的内容并没有词频。**没有词频就无法通过`wordcloud`来进行绘制！！！**,**求指教如何将关键词放入`wordcloud`进行绘制！！！**\n\n```\n#re为调用vector_keywords产生的结果\ndata.frame(re);\n#将结果输出到文件中\nwrite.csv(data.frame(re),\"F:/R/2345.csv\",row.names = T)\n```\n\n![通过调用关键词函数vector_keywords产生的结果](http://upload-images.jianshu.io/upload_images/1094385-87adec761690384e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**3. 提出出的词语如何能文字更多**\n在做词库处理时，我这边用了搜狗的词库替换了`jiabaR`的原来词库，因此可以出现类似于`神罗天征`这样的四字词语，在原来的词库里，连`宇智波`都是被分开的！但是如何把很短的一句话也提取出来呢，从最开始的弹幕可以看到，原文件中是有大量的重复的一句话，除了自己在搜狗词包之外设置固定的词语短句，不知道还有没有别的方法，欢迎指导。\n\n## R语言分词end\n最后的那个图被我做的太丑了，简直影响观看，我如果一开始能预料到分出来会这么丑……我万万不会去分的，而且现在做云文字的网站都自带分词好像是，所以……所以我也不知道我这是在干嘛……。**如有错误还请指教！**\n\n在整个过程中遇到的调试记录请移步[Python爬取B站弹幕+R语言分词安装调试报错记录](/2017/09/03/201709031632/)\n\n\n\n\n","tags":["Python"]}]