<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Macaca-NoSmoke遍历调研过程记录</title>
      <link href="/2018/06/29/201806292200/"/>
      <url>/2018/06/29/201806292200/</url>
      <content type="html"><![CDATA[<h4 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h4><p>本文主要介绍对于NoSmoke遍历Android App使用过程中的一些记录，通过源码打断点的方式及查看截图效果简单确定一些NoSmoke的内部机制，其中若有理解错误或不当之处还请多多指教。本文未多介绍环境搭建，环境搭建有需要再补。</p><h4 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h4><p>Macaca+NoSmoke+Android手机+Mac10.13.1</p><p>主要参考文档：</p><p><a href="https://macacajs.github.io/zh/environment-setup" target="_blank" rel="noopener">Macaca NoSmoke官方文档</a></p><p><a href="https://testerhome.com/topics/10075" target="_blank" rel="noopener">Macaca 自动遍历器 NoSmoke 发布公测</a></p><p><a href="https://testerhome.com/topics/11482" target="_blank" rel="noopener">基于 macaca 的遍历 NoSmoke</a></p><h4 id="NoSmoke启动流程"><a href="#NoSmoke启动流程" class="headerlink" title="NoSmoke启动流程"></a>NoSmoke启动流程</h4><p>NoSmoke其实是提供了一套遍历流程，Macaca作为服务端，NoSmoke作为客户端 去对手机进行一个遍历操作。</p><p>主要分以下步骤：</p><ul><li>开启Macaca服务端</li><li>更改NoSmoke配置</li><li>启动NoSmoke客户端</li><li>页面实时查看效果</li></ul><h4 id="NoSmoke结果页展示"><a href="#NoSmoke结果页展示" class="headerlink" title="NoSmoke结果页展示"></a>NoSmoke结果页展示</h4><p>首先来简单介绍一下NoSmoke的遍历结果页面，在图上简单的进行了一下标注，对于标注相关说明会在下面详细介绍</p><p><img src="https://upload-images.jianshu.io/upload_images/1094385-ba56e6220a89b3e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NoSmoke结果页面.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1094385-81d803037f508319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Digest对应的Actions列举"></p><p><img src="https://upload-images.jianshu.io/upload_images/1094385-363a1eadb94121ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NoSmoke图片简排页面"></p><h4 id="NoSmoke遍历流程"><a href="#NoSmoke遍历流程" class="headerlink" title="NoSmoke遍历流程"></a>NoSmoke遍历流程</h4><p>NoSmoke在遍历过程中核心步骤主要如下：</p><ul><li>确定页面Digest</li><li>确定页面的Action集合</li><li>确定页面的点击操作</li><li>循环该过程直至遍历结束<br>我们先简单的说明一下这4个步骤。</li></ul><h4 id="NoSmoke-Digest介绍"><a href="#NoSmoke-Digest介绍" class="headerlink" title="NoSmoke-Digest介绍"></a>NoSmoke-Digest介绍</h4><p>在上面的效果图中提到了Digest，Digest就相当于一个页面的唯一标识，即在自动化遍历页面时如何确定两个页面时相同的控件结构。</p><p>在NoSmoke的代码中<code>NoSmoke/lib/crawler/models.js</code>函数<code>NSAppCrawlingTreeNode.prototype.checkDigest</code>里提供了判断Digest的方法，核心代码如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.digest = <span class="string">''</span> + (<span class="keyword">source</span>.value.match(<span class="regexp">/node/g</span>) || []).length +</span><br><span class="line">            (<span class="keyword">source</span>.value.match(<span class="regexp">/Android/g</span>) || []).length +</span><br><span class="line">            (<span class="keyword">source</span>.value.match(<span class="regexp">/TextView/g</span>) || []).length +</span><br><span class="line">            (<span class="keyword">source</span>.value.match(<span class="regexp">/EditText/g</span>) || []).length +</span><br><span class="line">            (<span class="keyword">source</span>.value.match(<span class="regexp">/Layout/g</span>) || []).length +</span><br><span class="line">            (<span class="keyword">source</span>.value.match(<span class="regexp">/Button/g</span>) || []).length;</span><br></pre></td></tr></table></figure><p>从代码中可以看到每个页面根据Macaca返回的控件树的value值，匹配一定节点，拼接而成的Digest。因此我们看到的Digest是一串数字。图片上的View值就是唯一ID。</p><p><img src="https://upload-images.jianshu.io/upload_images/1094385-2c9af28aa975af67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Digest"></p><p>对于这个Digest，从页面效果来看它的区分程度准确率并不是特别的好，上面的图和下面的图区分来看是一样的页面，但是它们的Digest是不一样的。图片没有截全，下面的Digest是<code>520120411</code>,上面的图图像上标识是<code>520120421</code></p><p><img src="https://upload-images.jianshu.io/upload_images/1094385-412dc5d13e7cfb1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Digest"></p><p>个人认为页面唯一ID的确定本身就是一个有无数种选择的问题，可以说未必能有一种唯一的算法可以确定出所有APP的页面ID，因此NoSmoke也提供了hook，用户可以自己编写自己所确定页面ID的代码。</p><h4 id="NoSmoke-Action介绍"><a href="#NoSmoke-Action介绍" class="headerlink" title="NoSmoke-Action介绍"></a>NoSmoke-Action介绍</h4><p>当我们确定好这个页面的唯一ID时，页面中我们要去点击哪些控件呢？这就是Action集合所做的事情。</p><p>每一次请求页面Source时，都会返回页面的节点层级，在NoSmoke中通过不断的查询子节点，确定了每一个控件的执行路径。此处详细代码在<code>NoSmoke/lib/crawler/crawler.js</code>文件中的<code>NSCrawler.prototype.recursiveFilter</code>函数中 以下仅截取部分代码：主要是如果当前节点有子节点，进行递归循环，并生产<code>Xpath</code>路径</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 1. filter Current Node Information */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">source</span>.hasOwnProperty(<span class="string">'children'</span>)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (Array.isArray(<span class="keyword">source</span>.children)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; <span class="keyword">source</span>.children.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.eraseModelDifference(<span class="keyword">source</span>.children);</span><br><span class="line">      <span class="keyword">this</span>.insertXPath(<span class="keyword">source</span>, <span class="keyword">source</span>.children[i]);</span><br><span class="line">      let result = <span class="keyword">this</span>.recursiveFilter(<span class="keyword">source</span>.children[i], matches, exclusive);</span><br><span class="line">      sourceArray = sourceArray.concat(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.eraseModelDifference(<span class="keyword">source</span>.children);</span><br><span class="line">    <span class="keyword">this</span>.insertXPath(<span class="keyword">source</span>, <span class="keyword">source</span>.children);</span><br><span class="line">    let result = <span class="keyword">this</span>.recursiveFilter(<span class="keyword">source</span>.children, matches, exclusive);</span><br><span class="line">    sourceArray = sourceArray.concat(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产的路径如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1094385-9c3a53c71cec3b42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="页面Digest及对应Action路径"></p><p><strong>此处重点概括一下就是：</strong></p><ul><li>一个Digest会生产多个Action，这些Action集合为Actions</li><li>NoSmoke源码中设定Actions生产的最大数量为16</li><li>遍历路径达到的Action/所有Digest生产的Action为页面展示的百分比</li></ul><h5 id="Action具体生成"><a href="#Action具体生成" class="headerlink" title="Action具体生成"></a>Action具体生成</h5><p><img src="https://upload-images.jianshu.io/upload_images/1094385-0f21f2820137a003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="页面控件层级"></p><p>上图是页面的控件层级图。我们如果转化成模块简单化路径按下图层级为：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">a</span>-b-<span class="comment">d//这个结果是通过生产的Action和页面的层级路径相比对整理出来的，如有错误还请指出</span></span><br><span class="line"><span class="keyword">a</span>-b-e</span><br><span class="line"><span class="keyword">a</span>-f</span><br><span class="line"><span class="keyword">a</span>-g</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1094385-04eeb0b593b73576.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="灵魂画图"></p><p>上图里的c和h路径并没有被录入，用户可以匹配某种控件类型被过滤，如果父元素为被过滤的类型，那么子元素同样不会被选择。</p><h4 id="页面元素点击"><a href="#页面元素点击" class="headerlink" title="页面元素点击"></a>页面元素点击</h4><p>页面元素点击在<code>performAction</code>函数里，这里的逻辑就比较简单,主要是对于当前即将点击的元素进行类型判断<code>clickTypes</code>,<code>horizontalScrollTypes</code>,<code>editTypes</code>这三种分别为点击、滑动、输入三种类型，那么我们怎么知道过来的一个元素应该点击滑动还是输入呢？</p><p><strong>yml文件配置</strong><br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">horizontalScrollTypes:</span><br><span class="line">  -<span class="ruby"> <span class="string">'android.widget.ImageView'</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">'android.widget.TextView'</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">'android.widget.Button'</span></span></span><br><span class="line"><span class="ruby"><span class="symbol">clickTypes:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">'android.widget.Button'</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">'android.widget.TextView'</span></span></span><br><span class="line"><span class="ruby"><span class="symbol">editTypes:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">'android.widget.EditText'</span></span></span><br></pre></td></tr></table></figure></p><p>当前的元素是图片类型，它被设定为滑动类型，那么久会被滑动，当前图片是按钮，它既可以滑动也可以点击，按照下面代码中的if else逻辑会对其进行点击操作.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.config.clickTypes.indexOf(action.source.type) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">/** 1. handle click actions */</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            root.wdclient.send(<span class="string">'/wd/hub/session/'</span> + <span class="keyword">this</span>.sessionId + <span class="string">'/element/'</span> + action.data.value.ELEMENT + <span class="string">'/click'</span>, <span class="string">'post'</span>, &#123;&#125;, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.refreshScreen();</span><br><span class="line">              resolve();</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.config.horizontalScrollTypes.indexOf(action.source.type) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">/** 2. handle horizontal scroll actions */</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            root.wdclient.send(<span class="string">'/wd/hub/session/'</span> + <span class="keyword">this</span>.sessionId + <span class="string">'/actions'</span>, <span class="string">'post'</span>, &#123;<span class="string">'actions'</span>: [&#123;<span class="string">'type'</span>: <span class="string">'drag'</span>, <span class="string">'fromX'</span>: <span class="number">600</span>, <span class="string">'fromY'</span>: <span class="number">200</span>, <span class="string">'toX'</span>: <span class="number">10</span>, <span class="string">'toY'</span>: <span class="number">200</span>, <span class="string">'duration'</span>: <span class="number">2</span>&#125;]&#125;,<span class="comment">//这里滑动的坐标被我更改了</span></span><br><span class="line">              () =&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>.refreshScreen();</span><br><span class="line">                resolve();</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.config.editTypes.indexOf(action.source.type) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">/** 3. handle edit actions */</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            root.wdclient</span><br><span class="line">              .send(<span class="string">'/wd/hub/session/'</span> + <span class="keyword">this</span>.sessionId + <span class="string">'/element/'</span> + action.data.value.ELEMENT + <span class="string">'/value'</span>, <span class="string">'post'</span>, &#123;</span><br><span class="line">                <span class="string">'value'</span>: [action.input]</span><br><span class="line">              &#125;, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.refreshScreen();</span><br><span class="line">                resolve();</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环结束"><a href="#循环结束" class="headerlink" title="循环结束"></a>循环结束</h4><p>整个页面的遍历会在什么时候循环结束呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Terminate under the following cases:</span></span><br><span class="line">  <span class="comment">// 1. the previous node has been finished for continuously count of 8, assume crawling finish</span></span><br><span class="line">  <span class="comment">// 2. the crawling process takes too long and hence expire</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.repeatingCrawlingCount &gt;= maxRepeatCrawlingCount || <span class="keyword">this</span>.crawlingExpires) &#123;</span><br><span class="line">    <span class="keyword">this</span>.terminate(<span class="string">'terminate due to timeout'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>maxRepeatCrawlingCount 爬行的最大层数  默认为8</li><li>repeatingCrawlingCount  当前爬行的层数 </li><li>crawlingExpires   配置的时间 默认30min</li></ul><h5 id="页面深度设定规则"><a href="#页面深度设定规则" class="headerlink" title="页面深度设定规则"></a>页面深度设定规则</h5><ul><li>该页面为新的页面 repeatingCrawlingCount = 0</li><li>这个页面action全部被浏览完毕 且这个页面的父节点类型不是需要被过滤的repeatingCrawlingCount++  这是根据代码里的逻辑得出的这样一个结论，没有进行具体验证。</li></ul><h4 id="NoSmoke官方爬行原理图"><a href="#NoSmoke官方爬行原理图" class="headerlink" title="NoSmoke官方爬行原理图"></a>NoSmoke官方爬行原理图</h4><p>以上是我在通过打断点和页面效果观察过程中的一点记录，下面是官方公布的原理图，在上面做了小标志。官方高清大图请走链接</p><p><a href="https://testerhome.com/topics/10075" target="_blank" rel="noopener">Macaca 自动遍历器 NoSmoke 发布公测</a></p><p><img src="https://upload-images.jianshu.io/upload_images/1094385-f2de739099c55048.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从PPT上直接截取下来了"></p><h4 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h4><p>以上就是在NoSmoke调研过程中的一点个人记录，主要从四个方面结合源码和执行效果进行了简单分析，如有错误或者疏漏之处还请指出。</p><p>NoSmoke本身提供了很强的hook配置，及用户可以自己定义一系列的Action，最后的页面展示页特别赞，本次调研未调研iOS相关，因为WDA好像……又出问题了……</p><p>马上就7月份了，这篇就作为上半年的blog收尾，即将到来的7月份~你好啊~</p>]]></content>
      
      
        <tags>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我们仍未知道那天wda为什么没有被启动</title>
      <link href="/2018/04/16/201804162116/"/>
      <url>/2018/04/16/201804162116/</url>
      <content type="html"><![CDATA[<p> 这是一篇废话连篇的佛系记录，本文主要为appium+wda测试app过程中遇到的问题</p><h4 id="1-appium报错说明："><a href="#1-appium报错说明：" class="headerlink" title="1.appium报错说明："></a>1.appium报错说明：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib2.URLError: &lt;urlopen <span class="builtin-name">error</span> [Errno 61]<span class="built_in"> Connection </span>refused&gt;</span><br></pre></td></tr></table></figure><p>该问题为什么会发生至今仍不知道，一方面说是当前appium服务端没有被启动，但是在appium服务端启动之后仍曾经遇到过这个问题，无组织无纪律2%的概率复现。</p><p><strong>当前解决方式:通过增加重试次数重启appium</strong></p><h4 id="2-socket-hang-up"><a href="#2-socket-hang-up" class="headerlink" title="2.socket hang up"></a>2.socket hang up</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could <span class="keyword">not</span><span class="built_in"> proxy </span>command <span class="keyword">to</span> remote server. Original error: Error: socket hang up</span><br></pre></td></tr></table></figure><p>appium服务端挂起，该问题由于appium服务端什么原因导致尚未查明，每隔一段时间总会hang up一次。<br><strong>假装解决方式：选择在python脚本中对其异常进行捕获</strong><br>但是这个问题总是要查的……</p><h4 id="3-找不到证书"><a href="#3-找不到证书" class="headerlink" title="3.找不到证书"></a>3.找不到证书</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error: </span>App with bundle identifier 'xxxxxx'</span><br></pre></td></tr></table></figure><p>遇到这个问题一种是真的证书写错了，另一种，在程序执行了好久后报这个错误那就非常奇怪了……奇怪到至今也没有查到这个问题，但可以确定的是，随着mac连接设备不再频繁掉设备后，这个问题也逐渐减少了。</p><h4 id="4-找不到设备"><a href="#4-找不到设备" class="headerlink" title="4.找不到设备"></a>4.找不到设备</h4><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message: An unknown server-<span class="literal">side</span> <span class="literal">error</span> occurred <span class="keyword">while</span> processing the command. Original <span class="literal">error</span>: Unknown device <span class="keyword">or</span> simulator UDID: <span class="symbol">'balabalabalalbas</span>'</span><br></pre></td></tr></table></figure><p>大意就是找不到设备，尤其是在程序执行一段时间后失败了，失败原因找不到设备，就好像之前执行的一个小时都在闹着玩一样。<br>此时ituns会弹出各种弹框：eg’当前找不到该设备’ ‘无法像该设备传输信息’<br>所以简单粗暴的认为是设备掉线了，后来更换了HUB之后，该问题果然减少了！<strong>更换HUB</strong>之后连带着找不到证书的问题也<strong>果然</strong>减少了！</p><h4 id="httplib-BadStatusLine"><a href="#httplib-BadStatusLine" class="headerlink" title="httplib.BadStatusLine"></a>httplib.BadStatusLine</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise BadStatusLine(line) httplib<span class="selector-class">.BadStatusLine</span>: <span class="string">''</span></span><br></pre></td></tr></table></figure><p>网上查说是你的python请求中断啊，但是为什么会中断！网络好好的，什么都好好的，后来终于确定了现场，那就是报出该问题时99%是app证书没有被信任，暂定就破案吧。</p><h4 id="5-Too-many-instances"><a href="#5-Too-many-instances" class="headerlink" title="5.Too many instances"></a>5.Too many instances</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Too many instances <span class="keyword">of</span> this services are already <span class="built_in">running</span></span><br></pre></td></tr></table></figure><p>如果你的appium日志经常阵亡在wda启动时，满屏都是wda报错的日志时，不妨从xcodebuild中启动一下wda，经常会出现这个错误！除了重启手机别无它法。</p><h4 id="6-A-session-is-either-terminated-or-not-started"><a href="#6-A-session-is-either-terminated-or-not-started" class="headerlink" title="6.A session is either terminated or not started"></a>6.A session is either terminated or not started</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebDriverException: <span class="keyword">Message</span>: A session <span class="keyword">is</span> either terminated <span class="keyword">or</span> <span class="keyword">not</span> started</span><br></pre></td></tr></table></figure><p>大概就是当前的session已经停止了，再去连接是连接不上的，捕获到这种异常后，进行了appium重新请求，即重新建立appium与wda，wda与手机的session</p><h4 id="7-wda没有启动"><a href="#7-wda没有启动" class="headerlink" title="7.wda没有启动"></a>7.wda没有启动</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebDriverException: Message: <span class="keyword">An</span> unknown server-side <span class="keyword">error</span> occurred <span class="keyword">while</span> processing the command. Original <span class="keyword">error</span>: <span class="keyword">An</span> <span class="keyword">error</span> occurred</span><br></pre></td></tr></table></figure><p>element找不到，当前发送的命令webdriver中没有，都可能导致这个问题</p><h4 id="8-xcodebuild65"><a href="#8-xcodebuild65" class="headerlink" title="8.xcodebuild65"></a>8.xcodebuild65</h4><p>这个问题范围太广了，wda没有启动成功时，基本是成片的’xcodebuild 65’<br>且如果你上次执行失败导致xcodebuild65 and wda remove，之后的执行基本也是失败的。此时主要是通过xcodebuild重启wda来尽量避免成片出现这种错误。<br>当前可以确定的是：<br>手机弹出未安装sim卡，手机弹出alertView弹窗，手机未被信任都会阻止wda的启动。<br>重启手机，通过xcodebuild重启wda可以有效减少此类问题发生，但是可能不能避免。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>重启手机、重启wda、避免手机电量不足而导致重新信任电脑、增加appium启动重试次数、更换硬件设备、对于异常进行捕获而非抛出，大概就是以上要表达的全部意思。</p>]]></content>
      
      
        <tags>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于wda启动之后iproxy转发后仍然无法访问8100地址查找记录</title>
      <link href="/2018/04/16/201804061949/"/>
      <url>/2018/04/16/201804061949/</url>
      <content type="html"><![CDATA[<h4 id="成功现象说明："><a href="#成功现象说明：" class="headerlink" title="成功现象说明："></a>成功现象说明：</h4><p>一般来说在wda启动之后会生成地址http:xxx:8100,通过iproxy转发端口后，在浏览器中输出127.0.0.1:8100/status，即可返回json字符串，从而在浏览器中观察到wda返回的字符串。【假设iproxy端口转发为8100.】</p><h4 id="问题说明："><a href="#问题说明：" class="headerlink" title="问题说明："></a>问题说明：</h4><p>但是单独启动wda之后，面临着http:xxx:8100/status不能正常返回json字符串的情况。</p><p>xcodebuild中启动wda日志输出最后一行为<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S<span class="function"><span class="title">erverURLHere</span>-&gt;</span>http:<span class="comment">//172.24.39.75:0&lt;-ServerURLHere</span></span><br></pre></td></tr></table></figure></p><p>最后一行并没有输出8100！不同的版本表现的不同~<br>在这种情况下通过iproxy转发8100端口 在浏览器中输出127.0.0.1:8100是找不到的。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>如何修改：<br>通过命令行启动xcodebuild时加上<code>USE_PORT</code>参数来选定端口。<em>appium中更改wda端口也是通过这个参数来操作的</em><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/xcodebuild build-for-testing test-without-building -project /u</span>sr<span class="regexp">/local/</span>lib<span class="regexp">/node_modules/</span>appium<span class="regexp">/node_modules/</span>appium-xcuitest-driver<span class="regexp">/WebDriverAgent/</span>WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination id=请传入设备的udid USE_PORT=<span class="number">8100</span> test</span><br></pre></td></tr></table></figure></p><h4 id="问题查找过程blog记录："><a href="#问题查找过程blog记录：" class="headerlink" title="问题查找过程blog记录："></a>问题查找过程blog记录：</h4><p> <a href="https://testerhome.com/topics/10445" target="_blank" rel="noopener">Appium Destopv1.2.3 中 WDA 启动后监听 ip 和端口的疑问</a></p><p> <a href="https://github.com/facebook/WebDriverAgent/issues/538" target="_blank" rel="noopener">How can i change WebdriverAgent port with command-line parameters ?</a></p><p> <a href="https://github.com/appium/appium/issues/9547" target="_blank" rel="noopener">Appium 1.7.1, WDA ServerURLHere-&gt;http://…:0&lt;-ServerURLHere</a></p><p> <a href="https://github.com/facebook/WebDriverAgent/issues/661#issuecomment-338920833" target="_blank" rel="noopener">WDA does not listen port 8100 </a></p><p> <a href="https://blog.yuhanle.com/2018/01/03/how-to-install-web-driver-agent-on-device/" target="_blank" rel="noopener">关于端口转发iproxy</a></p>]]></content>
      
      
        <tags>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于搭建appium+wda环境时遇到的问题记录</title>
      <link href="/2018/04/16/201804161919/"/>
      <url>/2018/04/16/201804161919/</url>
      <content type="html"><![CDATA[<h4 id="xcodebuild报错："><a href="#xcodebuild报错：" class="headerlink" title="xcodebuild报错："></a>xcodebuild报错：</h4><p><strong>各种路径请对应自己电脑上的路径</strong><br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stderr</span>: xcode-select: error: tool <span class="string">'xcodebuild'</span> requires Xcode, but active developer <span class="built_in">directory</span> <span class="string">'/Library/Developer/CommandLineTools'</span> is <span class="keyword">a</span> <span class="keyword">command</span> <span class="title">line</span> <span class="title">tools</span> <span class="title">instance</span></span><br></pre></td></tr></table></figure></p><p>解决：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xcode-select --<span class="keyword">switch</span> <span class="regexp">/Applications/</span>Xcode6-Beta.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/</span></span><br></pre></td></tr></table></figure></p><hr><h4 id="java环境配置"><a href="#java环境配置" class="headerlink" title="java环境配置"></a>java环境配置</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home   </span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$JAVA_HOME</span>/bin:$PATH </span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">CLASSPATH</span>=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure><hr><h4 id="Homebrew报错"><a href="#Homebrew报错" class="headerlink" title="Homebrew报错"></a>Homebrew报错</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Homebrew: Could <span class="keyword">not</span> symlink, /usr/<span class="keyword">local</span>/bin <span class="keyword">is</span> <span class="keyword">not</span> writable]</span><br></pre></td></tr></table></figure><p>解决：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">chown</span> -R <span class="string">`whoami`</span>:admin /usr/<span class="keyword">local</span>/bin</span><br></pre></td></tr></table></figure></p><hr><h4 id="xcode报错："><a href="#xcode报错：" class="headerlink" title="xcode报错："></a>xcode报错：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-<span class="keyword">select</span>: <span class="keyword">error</span>: tool <span class="string">'xcodebuild'</span> requires Xcode, but active developer <span class="keyword">directory</span> <span class="string">'/Library/Developer/CommandLineTools'</span> <span class="keyword">is</span> a command line tools <span class="keyword">instance</span></span><br></pre></td></tr></table></figure><p>解决：在命令行工具中输入下面的命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xcode-select -s  <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer</span><br></pre></td></tr></table></figure><h4 id="icu4c问题："><a href="#icu4c问题：" class="headerlink" title="icu4c问题："></a>icu4c问题：</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dyld:</span> Library not <span class="symbol">loaded:</span> /usr/local/opt/icu4c/<span class="class"><span class="keyword">lib</span>/<span class="title">libicui18n</span>.61.<span class="title">dylib</span></span></span><br><span class="line">  Referenced <span class="symbol">from:</span> /usr/local/bin/node</span><br><span class="line">  <span class="symbol">Reason:</span> image not found</span><br><span class="line">Abort <span class="symbol">trap:</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>解决：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>icu4c</span><br><span class="line"><span class="keyword">brew </span>link icu4c --force</span><br></pre></td></tr></table></figure></p><h4 id="wda报错"><a href="#wda报错" class="headerlink" title="wda报错"></a>wda报错</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This application’s application-identifier entitlement does <span class="keyword">not</span> match that of the installed application. These values must match <span class="keyword">for</span> an<span class="built_in"> upgrade </span><span class="keyword">to</span> be allowed.</span><br></pre></td></tr></table></figure><p>在不同mac上测试时用的都是同一台手机，上个mac上装的wda可能不适合下一台，所以卸载了wda后  新环境可以正常安装wda</p><h4 id="openssl-broken"><a href="#openssl-broken" class="headerlink" title="openssl broken"></a>openssl broken</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error: </span>/usr/local/opt/openssl not present or broken</span><br><span class="line">Please reinstall openssl. Sorry :(</span><br></pre></td></tr></table></figure><p>brew install openssl<br>安装之后准备 <code>brew link openssl</code>时报错，报错如下：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Warning: Refusing <span class="keyword">to</span> link: openssl</span><br><span class="line">Linking keg-only openssl means you may <span class="keyword">end</span> up linking <span class="keyword">against</span> <span class="keyword">the</span> insecure,</span><br><span class="line">deprecated system OpenSSL <span class="keyword">while</span> using <span class="keyword">the</span> headers <span class="keyword">from</span> Homebrew's openssl.</span><br><span class="line">Instead, pass <span class="keyword">the</span> full include/library paths <span class="keyword">to</span> your compiler e.g.:</span><br><span class="line">  -I/usr/<span class="keyword">local</span>/opt/openssl/include -L/usr/<span class="keyword">local</span>/opt/openssl/lib</span><br></pre></td></tr></table></figure></p><p>brew link openssl –force仍然报错<br>最终输入：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/opt/openssl/<span class="class"><span class="keyword">lib</span>/<span class="title">libcrypto</span>.1.0.0.<span class="title">dylib</span> /<span class="title">usr</span>/<span class="title">local</span>/<span class="title">lib</span>/</span></span><br><span class="line"></span><br><span class="line">ln -s /usr/local/opt/openssl/<span class="class"><span class="keyword">lib</span>/<span class="title">libssl</span>.1.0.0.<span class="title">dylib</span> /<span class="title">usr</span>/<span class="title">local</span>/<span class="title">lib</span>/</span></span><br></pre></td></tr></table></figure></p><p>openssl问题解决来源于<a href="https://blog.csdn.net/jiamian_/article/details/55098125" target="_blank" rel="noopener">该blog</a></p>]]></content>
      
      
        <tags>
            
            <tag> Appium环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Appium在vscode中调试说明</title>
      <link href="/2018/02/22/201802221759/"/>
      <url>/2018/02/22/201802221759/</url>
      <content type="html"><![CDATA[<h4 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h4><p>要对appium的源码进行调试，如果选择全局安装的难免会在调试过程中破坏原代码，因此从github上面拉下了master分支的代码进行调试   <a href="https://github.com/appium/appium.git" target="_blank" rel="noopener">github代码：</a></p><h4 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h4><p>vscode </p><p>appium 1.7.2</p><p>mac</p><h4 id="安装appium"><a href="#安装appium" class="headerlink" title="安装appium"></a>安装appium</h4><p>要使拽下来的代码达到可运行状态，需要执行<code>npm install</code>但是这个安装过程中如果出现下载不成功的问题，原因可能是没有翻墙，导致无法下载chromedriver,因此建议翻箱后重新<code>npm install</code></p><h4 id="调试文件配置"><a href="#调试文件配置" class="headerlink" title="调试文件配置"></a>调试文件配置</h4><p>在vscode中打开appium所在的文件夹，要在debug时对vscode的launch.json进行配置,关于它的debug流程官网地址<a href="https://code.visualstudio.com/docs/editor/debugging" target="_blank" rel="noopener">https://code.visualstudio.com/docs/editor/debugging</a>介绍的比较详细，我用的launch.json配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;node&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Launch Program&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/lib/main.js&quot;,//package.json中的默认入口</span><br><span class="line">            &quot;console&quot; : &quot;integratedTerminal&quot;  //控制台信息的显示</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>调试文件运行好后，就可以在debug中运行按钮启动appium了，启动后就可以打断点进行调试了。</p><h4 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h4><p>在appium调试过程中发现，文件夹中会有build和其它文件夹，而入口文件一般都在build文件夹下，可是build文件夹中的代码又是被转换过的，我们如果在非build文件下更改又不会生效，那么这个时候要怎么办呢？</p><p>首先说原因，appium是用nodejs写成的，其中用了js的一些新特性，不能被直接识别执行，因此需要通过babel将代码转换一下，因此转换前的代码在lib中，转换后的代码在build中，appium及其所有的类库都是这样的方式，转换时用的打包工具是gulp。</p><p>由于执行的是build中的文件，而我们改代码都在转换前的文件夹lib下，所以需要对修改的代码进行打包。<br>进入gulpfiles.js所在的文件夹下，执行<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> build</span></span><br></pre></td></tr></table></figure></p><p>就可以将代码修改了。</p><p>有时候调试代码时需要涉及到在node_modules<br>中的<code>appium-base-driver</code>,<code>appium-xcuitest-driver</code>,<code>appium-android-driver</code>等各种类库中修改，这就需要我们在每一个类库中修改后都要进行打包,目前还没有找到gulp在node中的中间件，就是全部都打包的那种，之前只用过webpack的中间件，如果有小伙伴知道怎么在执行node时用gulp全部打包一下，还请告知哈。</p>]]></content>
      
      
        <tags>
            
            <tag> Appium环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Appium通过日志分析服务端执行过程-IOS端</title>
      <link href="/2018/02/22/201802221449/"/>
      <url>/2018/02/22/201802221449/</url>
      <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ol><li>本文日志为在IOS模拟器上进行的测试 appium 1.7.2</li><li>在appium服务端中，日志分为log.info和log.debug 一般每个文件夹下面都有logger.js 该js中规定当前log格式。</li><li>info为基础信息，debug可以看做为调试信息。</li><li>本篇为初步分析，后来对日志又进行了更细致的断点查找，待整理，如有错误还请指出</li><li>假如日志前面打印出的[Appium][XUCITES]等，根据该名字可以查到日志来源于哪个文件夹下，[debug][MJSONWP]代表当前是采用log.debug方式打印日志，且日志来源于<code>appium-base-driver/mjsonwp</code>的文件夹</li></ol><h4 id="第一部分-启动服务并创建sessionID"><a href="#第一部分-启动服务并创建sessionID" class="headerlink" title="第一部分 启动服务并创建sessionID"></a>第一部分 启动服务并创建sessionID</h4><p>appium启动：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Appium] Welcome <span class="keyword">to</span> Appium v1.7.2</span><br><span class="line">[Appium] Appium REST http<span class="built_in"> interface </span>listener started on 0.0.0.0:4723</span><br></pre></td></tr></table></figure></p><p>客户端发送http请求，并传递配置参数<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[HTTP] --&gt; POST /wd/hub/session &#123;<span class="string">"capabilities"</span>:&#123;<span class="string">"alwaysMatch"</span>:&#123;<span class="string">"platformName"</span>:<span class="string">"iOS"</span>&#125;,<span class="string">"firstMatch"</span>:[&#123;&#125;]&#125;,<span class="string">"desiredCapabilities"</span>:&#123;<span class="string">"platformVersion"</span>:<span class="string">"11.2"</span>,<span class="string">"deviceName"</span>:<span class="string">"iPhone 6s"</span>,<span class="string">"app"</span>:<span class="string">"/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app"</span>,<span class="string">"platformName"</span>:<span class="string">"iOS"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>[MJSONWP]为来自于appium服务端中封装好的类库<code>appium-base-driver</code>中mjsonwp文件夹下的mjsonwp.js，一般用于server端的交互，包括处理HTTP的请求，session会话的创建删除。以下为创建Session<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[debug] [<span class="symbol">MJSONWP</span>] <span class="symbol">Calling</span> <span class="symbol">AppiumDriver</span>.createSession() with args: [&#123;<span class="string">"platformVersion"</span>:<span class="string">"11.2"</span>,<span class="string">"deviceName"</span>:<span class="string">"iPhone 6s"</span>,<span class="string">"app"</span>:<span class="string">"/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app"</span>,<span class="string">"platformName"</span>:<span class="string">"iOS"</span>&#125;,null,&#123;<span class="string">"alwaysMatch"</span>:&#123;<span class="string">"platformName"</span>:<span class="string">"iOS"</span>&#125;,<span class="string">"firstMatch"</span>:[&#123;&#125;]&#125;]</span><br></pre></td></tr></table></figure></p><p>[BaseDriver]日志来源于<code>appium-base-driver/basedriver</code>文件夹。<br>下面日志主要用于打印整个appium中的事件触发，所有的请求都会触发各种类下的<code>executeCommand</code>函数，而这些函数全部继承driver.js中的WebDriver，所以所有的请求都会打印出<code>driver.js</code>中的logHistory。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">debug</span>] [<span class="keyword">BaseDriver] </span>Event <span class="string">'newSessionRequested'</span> logged <span class="built_in">at</span> <span class="number">1516514435268</span> (<span class="number">14</span>:<span class="number">00</span>:<span class="number">35</span> GMT+<span class="number">0800</span> (CST))</span><br></pre></td></tr></table></figure></p><p>[Appium]日志来源于<code>lib</code>文件夹下<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Appium] Merged W3C capabilities &#123;<span class="string">"alwaysMatch"</span>:&#123;<span class="string">"platformName"</span>:<span class="string">"iOS"</span>&#125;,<span class="string">"firstMat... into desiredCapabilities object &#123;"</span>platformVersion<span class="string">":"</span><span class="number">11.2</span><span class="string">","</span>deviceName<span class="string">":"</span>iPhone ...</span><br><span class="line">[Appium] Requested iOS support with version &gt;= <span class="number">10</span>, using XCUITest driver instead of UIAutomation-based driver, since the latter is unsupported on iOS <span class="number">10</span> and up.</span><br><span class="line">[Appium] Creating <span class="keyword">new</span> XCUITestDriver (v2<span class="number">.64</span><span class="number">.0</span>) session</span><br><span class="line">[Appium] <span class="string">Capabilities:</span></span><br><span class="line">[Appium]   <span class="string">platformVersion:</span> <span class="number">11.2</span></span><br><span class="line">[Appium]   <span class="string">deviceName:</span> iPhone <span class="number">6</span>s</span><br><span class="line">[Appium]   <span class="string">app:</span> <span class="regexp">/Users/</span>用户名<span class="regexp">/Documents/</span>github<span class="regexp">/python-client-master/</span>appium<span class="regexp">/TestApp/</span>build<span class="regexp">/release-iphonesimulator/</span>TestApp-iphonesimulator.app</span><br><span class="line">[Appium]   <span class="string">platformName:</span> iOS</span><br></pre></td></tr></table></figure></p><p>[BaseDriver]打印出当前sessionId创建成功，来源于<code>appium-base-driver/basedriver/session.js</code>文件。</p><ul><li>creatSession跳转过程说明：<br>创建creatSession路线：mjsonwp.js-》appium.js中的createSession-》跳转到XCUITEST中的createSession-》跳转到appium-base-driver/basedriver/driver.js中的creatSession</li><li>如何联系起了XCUITest？<br>通过appium.js中的<code>curSessionDataForDriver(InnerDriver)</code>，当判断出当前是什么系统配置时，InnerDriver此时已变成IOS或者Android的Driver</li></ul><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BaseDriver] Session created <span class="keyword">with</span> session <span class="attribute">id:</span><span class="string"> 8790f1db</span><span class="number">-9627</span><span class="number">-41</span>ce-a534-bc40159c7194</span><br></pre></td></tr></table></figure><p>当创建SessionID之后，此时进入的是<code>appium-xcuitest-driver</code>类库中。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">debug</span>] [XCUITest] Current user: <span class="string">'用户名'</span></span><br><span class="line">[<span class="keyword">debug</span>] [XCUITest] Current <span class="keyword">version</span> of libimobiledevice: stable <span class="number">1.2</span>.<span class="number">0</span> (bottled), HEAD</span><br><span class="line">[<span class="keyword">debug</span>] [XCUITest] Xcode <span class="keyword">version</span> <span class="keyword">set</span> <span class="keyword">to</span> <span class="string">'9.2'</span> (tools v9.<span class="number">2.0</span>.<span class="number">0.1</span>.<span class="number">1510905681</span>)</span><br><span class="line">[<span class="keyword">debug</span>] [XCUITest] iOS SDK Version <span class="keyword">set</span> <span class="keyword">to</span> <span class="string">'11.2'</span></span><br></pre></td></tr></table></figure></p><p>来自于<code>appium-base-driver/basedriver/driver.js</code>中的logHistory函数<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">debug</span>] [<span class="keyword">BaseDriver] </span>Event <span class="string">'xcodeDetailsRetrieved'</span> logged <span class="built_in">at</span> <span class="number">1516514436354</span> (<span class="number">14</span>:<span class="number">00</span>:<span class="number">36</span> GMT+<span class="number">0800</span> (CST))</span><br></pre></td></tr></table></figure></p><p>[iOSSim]来自于<code>appium-ios-simulator</code>的日志，接下来都是在IOS检测模拟器，判断APP，安装APP的操作<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[iOSSim] Constructing iOS simulator for Xcode version 9.2 with udid '2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5'</span><br><span class="line">[XCUITest] Determining device to run tests on: udid: '2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5', real device: false</span><br><span class="line">[BaseDriver] Using local app '/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/<span class="keyword">release</span>-iphonesimulator/TestApp-iphonesimulator.app<span class="string">'</span></span><br><span class="line"><span class="string">[debug] [BaseDriver] Event '</span>appConfigured<span class="string">' logged at 1516514436692 (14:00:36 GMT+0800 (CST))</span></span><br><span class="line"><span class="string">[debug] [XCUITest] Checking whether app '</span>/<span class="keyword">Users</span>/用户名/Documents/github/python-<span class="keyword">client</span>-<span class="keyword">master</span>/appium/TestApp/<span class="keyword">build</span>/<span class="keyword">release</span>-iphonesimulator/TestApp-iphonesimulator.app<span class="string">' is actually present on file system</span></span><br><span class="line"><span class="string">[debug] [XCUITest] App is present</span></span><br><span class="line"><span class="string">[debug] [iOS] Getting bundle ID from app '</span>/<span class="keyword">Users</span>/用户名/Documents/github/python-<span class="keyword">client</span>-<span class="keyword">master</span>/appium/TestApp/<span class="keyword">build</span>/<span class="keyword">release</span>-iphonesimulator/TestApp-iphonesimulator.app<span class="string">': '</span>io.appium.TestApp<span class="string">'</span></span><br><span class="line"><span class="string">[debug] [BaseDriver] Event '</span>resetStarted<span class="string">' logged at 1516514436695 (14:00:36 GMT+0800 (CST))</span></span><br><span class="line"><span class="string">[XCUITest] Not scrubbing third party app in anticipation of uninstall</span></span><br><span class="line"><span class="string">[debug] [BaseDriver] Event '</span>resetComplete<span class="string">' logged at 1516514436881 (14:00:36 GMT+0800 (CST))</span></span><br><span class="line"><span class="string">[debug] [XCUITest] Starting log capture for iOS Simulator with udid '</span><span class="number">2</span>EF911A2-CA9C<span class="number">-4</span>D28<span class="number">-96</span>EB<span class="number">-3</span>DBC8DF39FA5<span class="string">', using '</span>xcrun simctl spawn <span class="number">2</span>EF911A2-CA9C<span class="number">-4</span>D28<span class="number">-96</span>EB<span class="number">-3</span>DBC8DF39FA5 <span class="keyword">log</span> stream <span class="comment">--style compact'</span></span><br><span class="line">[debug] [BaseDriver] <span class="keyword">Event</span> <span class="string">'logCaptureStarted'</span> logged <span class="keyword">at</span> <span class="number">1516514437312</span> (<span class="number">14</span>:<span class="number">00</span>:<span class="number">37</span> GMT+<span class="number">0800</span> (CST))</span><br><span class="line">[XCUITest] Setting up simulator</span><br><span class="line">[debug] [iOS] <span class="keyword">No</span> reason <span class="keyword">to</span> <span class="keyword">set</span> locale</span><br><span class="line">[debug] [iOS] <span class="keyword">No</span> iOS / app preferences <span class="keyword">to</span> <span class="keyword">set</span></span><br><span class="line">[debug] [iOSSim] <span class="keyword">Matched</span> <span class="number">1</span> Simulator <span class="keyword">cache</span> item <span class="keyword">for</span> <span class="keyword">cleanup</span>: /<span class="keyword">Users</span>/用户名/<span class="keyword">Library</span>/Developer/CoreSimulator/Devices/<span class="number">2</span>EF911A2-CA9C<span class="number">-4</span>D28<span class="number">-96</span>EB<span class="number">-3</span>DBC8DF39FA5/<span class="keyword">data</span>/<span class="keyword">Library</span>/Caches/com.apple.mobile.installd.staging</span><br><span class="line">[debug] [iOSSim] Setting common Simulator preferences <span class="keyword">to</span> &#123;<span class="string">"ConnectHardwareKeyboard"</span>:<span class="literal">false</span>&#125;</span><br><span class="line">[debug] [iOSSim] <span class="keyword">Updated</span> <span class="number">2</span>EF911A2-CA9C<span class="number">-4</span>D28<span class="number">-96</span>EB<span class="number">-3</span>DBC8DF39FA5 Simulator preferences <span class="keyword">at</span> <span class="string">'/Users/用户名/Library/Preferences/com.apple.iphonesimulator.plist'</span> <span class="keyword">with</span> &#123;<span class="string">"ConnectHardwareKeyboard"</span>:<span class="literal">false</span>&#125;</span><br><span class="line">[debug] [iOSSim] The <span class="keyword">count</span> <span class="keyword">of</span> running Simulator UI <span class="keyword">client</span> instances <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">[iOSSim] <span class="keyword">Both</span> Simulator <span class="keyword">with</span> UDID <span class="number">2</span>EF911A2-CA9C<span class="number">-4</span>D28<span class="number">-96</span>EB<span class="number">-3</span>DBC8DF39FA5 <span class="keyword">and</span> the UI <span class="keyword">client</span> <span class="keyword">are</span> currently running</span><br><span class="line">[debug] [BaseDriver] <span class="keyword">Event</span> <span class="string">'simStarted'</span> logged <span class="keyword">at</span> <span class="number">1516514437783</span> (<span class="number">14</span>:<span class="number">00</span>:<span class="number">37</span> GMT+<span class="number">0800</span> (CST))</span><br><span class="line">[debug] [XCUITest] <span class="keyword">Reset</span> requested. Removing app <span class="keyword">with</span> <span class="keyword">id</span> <span class="string">'io.appium.TestApp'</span> <span class="keyword">from</span> the device</span><br><span class="line">[debug] [XCUITest] Installing <span class="string">'/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app'</span> <span class="keyword">on</span> Simulator <span class="keyword">with</span> <span class="keyword">UUID</span> <span class="string">'2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5'</span>...</span><br><span class="line">[debug] [XCUITest] The app has been installed successfully.</span><br><span class="line">[debug] [BaseDriver] <span class="keyword">Event</span> <span class="string">'appInstalled'</span> logged <span class="keyword">at</span> <span class="number">1516514440337</span> (<span class="number">14</span>:<span class="number">00</span>:<span class="number">40</span> GMT+<span class="number">0800</span> (CST))</span><br></pre></td></tr></table></figure></p><p>APP安装成功之后开始处理WDA<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[XCUITest] Using WDA path: '/usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgent'</span><br><span class="line">[XCUITest] Using WDA agent: '/usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgent/WebDriverAgent.xcodeproj'</span><br><span class="line">[debug] [XCUITest] No obsolete cached processes from previous WDA sessions listening on port 8100 have been found</span><br><span class="line">[debug] [JSONWP Proxy] Proxying [GET /status] to [GET http://localhost:8100/status] with no body</span><br><span class="line">[debug] [JSONWP Proxy] Got response with status 200: "&#123;<span class="symbol">\n</span>  <span class="symbol">\"</span>value<span class="symbol">\"</span> : &#123;<span class="symbol">\n</span>    <span class="symbol">\"</span>state<span class="symbol">\"</span> : <span class="symbol">\"</span>success<span class="symbol">\"</span>,<span class="symbol">\n</span>    <span class="symbol">\"</span>os<span class="symbol">\"</span> : &#123;<span class="symbol">\n</span>      <span class="symbol">\"</span>name<span class="symbol">\"</span> : <span class="symbol">\"</span>iOS<span class="symbol">\"</span>,<span class="symbol">\n</span>      <span class="symbol">\"</span>version<span class="symbol">\"</span> : <span class="symbol">\"</span>11.2<span class="symbol">\"</span>,<span class="symbol">\n</span>      <span class="symbol">\"</span>sdkVersion<span class="symbol">\"</span> : <span class="symbol">\"</span>11.2<span class="symbol">\"</span><span class="symbol">\n</span>    &#125;,<span class="symbol">\n</span>    <span class="symbol">\"</span>ios<span class="symbol">\"</span> : &#123;<span class="symbol">\n</span>      <span class="symbol">\"</span>simulatorVersion<span class="symbol">\"</span> : <span class="symbol">\"</span>11.2<span class="symbol">\"</span>,<span class="symbol">\n</span>      <span class="symbol">\"</span>ip<span class="symbol">\"</span> : <span class="symbol">\"</span>192.168.0.102<span class="symbol">\"</span><span class="symbol">\n</span>    &#125;,<span class="symbol">\n</span>    <span class="symbol">\"</span>build<span class="symbol">\"</span> : &#123;<span class="symbol">\n</span>      <span class="symbol">\"</span>time<span class="symbol">\"</span> : <span class="symbol">\"</span>Jan 14 2018 23:25:10<span class="symbol">\"</span><span class="symbol">\n</span>    &#125;<span class="symbol">\n</span>  &#125;,<span class="symbol">\n</span>  <span class="symbol">\"</span>sessionId<span class="symbol">\"</span> : <span class="symbol">\"</span>17DE3FB9-3196-4C9C-9D55-3BFFDD0C1DEB<span class="symbol">\"</span>,<span class="symbol">\n</span>  <span class="symbol">\"</span>status<span class="symbol">\"</span> : 0<span class="symbol">\n</span>&#125;"</span><br><span class="line">[XCUITest] Will reuse previously cached WDA instance at 'http://localhost:8100/'. Set the wdaLocalPort capability to a value different from 8100 if this is an undesired behavior.</span><br><span class="line">[debug] [BaseDriver] Event 'wdaStartAttempted' logged at 1516514440422 (14:00:40 GMT+0800 (CST))</span><br><span class="line">[XCUITest] Using provided WebdriverAgent at 'http://localhost:8100/'</span><br><span class="line">[debug] [BaseDriver] Event 'wdaSessionAttempted' logged at 1516514440423 (14:00:40 GMT+0800 (CST))</span><br><span class="line">[debug] [XCUITest] Sending createSession command to WDA</span><br></pre></td></tr></table></figure></p><p>在XCUITest中开启WDA之后，此时链接的request和response进入了  <code>appium-base-driver/lib/jsonwp-proxyproxy.js</code> ，这个js主要是做S/D的链接，即server服务端与devices设备的链接<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[debug]</span> <span class="string">[JSONWP Proxy]</span> Proxying <span class="string">[GET /status]</span> to <span class="string">[GET http://localhost:8100/status]</span> with no body</span><br><span class="line"><span class="string">[debug]</span> <span class="string">[JSONWP Proxy]</span> Got response with status <span class="number">200</span>: <span class="string">"&#123;\n  \"</span>value\<span class="string">" : &#123;\n    \"</span>state\<span class="string">" : \"</span>success\<span class="string">",\n    \"</span>os\<span class="string">" : &#123;\n      \"</span>name\<span class="string">" : \"</span>iOS\<span class="string">",\n      \"</span>version\<span class="string">" : \"</span><span class="number">11</span>.<span class="number">2</span>\<span class="string">",\n      \"</span>sdkVersion\<span class="string">" : \"</span><span class="number">11</span>.<span class="number">2</span>\<span class="string">"\n    &#125;,\n    \"</span>ios\<span class="string">" : &#123;\n      \"</span>simulatorVersion\<span class="string">" : \"</span><span class="number">11</span>.<span class="number">2</span>\<span class="string">",\n      \"</span>ip\<span class="string">" : \"</span><span class="number">192.168.0.102</span>\<span class="string">"\n    &#125;,\n    \"</span>build\<span class="string">" : &#123;\n      \"</span>time\<span class="string">" : \"</span>Jan <span class="number">14</span> <span class="number">2018</span> <span class="number">23</span>:<span class="number">25</span>:<span class="number">10</span>\<span class="string">"\n    &#125;\n  &#125;,\n  \"</span>sessionId\<span class="string">" : \"</span>17DE3FB9-<span class="number">3196</span>-4C9C-9D55-3BFFDD0C1DEB\<span class="string">",\n  \"</span>status\<span class="string">" : 0\n&#125;"</span></span><br><span class="line"><span class="string">[debug]</span> <span class="string">[JSONWP Proxy]</span> Proxying <span class="string">[POST /session]</span> to <span class="string">[POST http://localhost:8100/session]</span> with body: &#123;<span class="string">"desiredCapabilities"</span>:&#123;<span class="string">"bundleId"</span>:<span class="string">"io.appium.TestApp"</span>,<span class="string">"arguments"</span>:<span class="string">[]</span>,<span class="string">"environment"</span>:&#123;&#125;,<span class="string">"shouldWaitForQuiescence"</span>:true,<span class="string">"shouldUseTestManagerForVisibilityDetection"</span>:false,<span class="string">"maxTypingFrequency"</span>:<span class="number">60</span>,<span class="string">"shouldUseSingletonTestManager"</span>:true&#125;&#125;</span><br><span class="line"><span class="string">[debug]</span> <span class="string">[JSONWP Proxy]</span> Got response with status <span class="number">200</span>: &#123;<span class="string">"value"</span>:&#123;<span class="string">"sessionId"</span>:<span class="string">"95403F32-CD9B-4A0E-AA89-4BE9C899FBBC"</span>,<span class="string">"capabilities"</span>:&#123;<span class="string">"device"</span>:<span class="string">"iphone"</span>,<span class="string">"browserName"</span>:<span class="string">"TestApp"</span>,<span class="string">"sdkVersion"</span>:<span class="string">"11.2"</span>,<span class="string">"CFBundleIdentifier"</span>:<span class="string">"io.appium.TestApp"</span>&#125;&#125;,<span class="string">"sessionId"</span>:<span class="string">"95403F32-CD9B-4A0E-AA89-4BE9C899FBBC"</span>,<span class="string">"status"</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="string">[debug]</span> <span class="string">[BaseDriver]</span> Event 'wdaSessionStarted' logged at <span class="number">1516514443103</span> (<span class="number">14</span>:<span class="number">00</span>:<span class="number">43</span> GMT+<span class="number">0800</span> (CST))</span><br><span class="line"><span class="string">[debug]</span> <span class="string">[BaseDriver]</span> Event 'wdaStarted' logged at <span class="number">1516514443103</span> (<span class="number">14</span>:<span class="number">00</span>:<span class="number">43</span> GMT+<span class="number">0800</span> (CST))</span><br><span class="line"><span class="string">[XCUITest]</span> Skipping setting of the initial display orientation. Set the <span class="string">"orientation"</span> capability to either <span class="string">"LANDSCAPE"</span> or <span class="string">"PORTRAIT"</span>, if this is an undesired behavior.</span><br><span class="line"><span class="string">[debug]</span> <span class="string">[BaseDriver]</span> Event 'orientationSet' logged at <span class="number">1516514443103</span> (<span class="number">14</span>:<span class="number">00</span>:<span class="number">43</span> GMT+<span class="number">0800</span> (CST))</span><br></pre></td></tr></table></figure></p><p>上边WDA开启完毕，session创建成功，这个session的创建过程是从</p><p><strong>mjsonwp.js（HTTP请求入口）-》appium.js中的createSession-》跳转到XCUITEST中的createSession-》跳转到appium-base-driver/basedriver/driver.js中的creatSession   创建成功之后回到了appium.js中将log打印，最后回到了mjsonwp.js将response返回并通知。</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Appium] New XCUITestDriver session created successfully, session <span class="number">8790</span>f1db<span class="number">-9627</span><span class="number">-41</span>ce-a534-bc40159c7194 added <span class="keyword">to</span> master session <span class="built_in">list</span></span><br><span class="line">[debug] [BaseDriver] Event 'newSessionStarted' logged <span class="keyword">at</span> <span class="number">1516514443104</span> (<span class="number">14</span>:<span class="number">00</span>:<span class="number">43</span> GMT+<span class="number">0800</span> (CST))</span><br><span class="line">[debug] [MJSONWP] Responding <span class="keyword">to</span> client <span class="keyword">with</span> driver.createSession() <span class="literal">result</span>: &#123;<span class="string">"webStorageEnabled"</span>:<span class="literal">false</span>,<span class="string">"locationContextEnabled"</span>:<span class="literal">false</span>,<span class="string">"browserName"</span>:<span class="string">""</span>,<span class="string">"platform"</span>:<span class="string">"MAC"</span>,<span class="string">"javascriptEnabled"</span>:<span class="literal">true</span>,<span class="string">"databaseEnabled"</span>:<span class="literal">false</span>,<span class="string">"takesScreenshot"</span>:<span class="literal">true</span>,<span class="string">"networkConnectionEnabled"</span>:<span class="literal">false</span>,<span class="string">"platformVersion"</span>:<span class="string">"11.2"</span>,<span class="string">"deviceName"</span>:<span class="string">"iPhone 6s"</span>,<span class="string">"app"</span>:<span class="string">"/Users/用户名/Documents/github/python-client-master/appium/TestApp/build/release-iphonesimulator/TestApp-iphonesimulator.app"</span>,<span class="string">"platformName"</span>:<span class="string">"iOS"</span>,<span class="string">"udid"</span>:<span class="string">"2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5"</span>&#125;</span><br><span class="line">[HTTP] &lt;<span class="comment">-- POST /wd/hub/session 200 7841 ms - 515</span></span><br></pre></td></tr></table></figure><hr><h4 id="第二部分-发送操作请求执行并返回"><a href="#第二部分-发送操作请求执行并返回" class="headerlink" title="第二部分 发送操作请求执行并返回"></a>第二部分 发送操作请求执行并返回</h4><p>客户端传来请求获取element，该请求进入mjsonwp.js进行处理，通过executeCommand函数进入appium.js 进入appium-xcuitest-driver‘类库 与JSONWP Proxy[appium-base-driver/lib/jsonwp/proxy.js]进行协议交互  交互结果返回MJSONWP[appium-base-driver/lib/mjsonwp/mjsonwp.js]<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[HTTP] --&gt; POST /wd/hub/session/<span class="number">8790</span>f1db-<span class="number">9627</span>-<span class="number">41</span><span class="keyword">ce</span>-a534-bc40159c7194/element &#123;<span class="string">"using"</span>:<span class="string">"accessibility id"</span>,<span class="string">"sessionId"</span>:<span class="string">"8790f1db-9627-41ce-a534-bc40159c7194"</span>,<span class="string">"value"</span>:<span class="string">"TextField1"</span>&#125;</span><br><span class="line">[<span class="keyword">debug</span>] [MJSONWP] Calling AppiumDriver.findElement() with arg<span class="variable">s:</span> [<span class="string">"accessibility id"</span>,<span class="string">"TextField1"</span>,<span class="string">"8790f1db-9627-41ce-a534-bc40159c7194"</span>]</span><br><span class="line">[<span class="keyword">debug</span>] [XCUITest] Executing <span class="keyword">command</span> <span class="string">'findElement'</span></span><br><span class="line">[<span class="keyword">debug</span>] [BaseDriver] Valid locator strategies <span class="keyword">for</span> this reques<span class="variable">t:</span> xpath, id, name, class name, -ios predicate <span class="built_in">string</span>, -ios class chain, accessibility id</span><br><span class="line">[<span class="keyword">debug</span>] [BaseDriver] Waiting <span class="keyword">up</span> <span class="keyword">to</span> <span class="number">0</span> ms <span class="keyword">for</span> condition</span><br><span class="line">[<span class="keyword">debug</span>] [JSONWP Proxy] Proxying [POST /element] <span class="keyword">to</span> [POST http://localhos<span class="variable">t:8100</span>/session/<span class="number">95403</span>F32-CD9B-<span class="number">4</span>A0E-AA89-<span class="number">4</span>BE9C899FBBC/element] with body: &#123;<span class="string">"using"</span>:<span class="string">"accessibility id"</span>,<span class="string">"value"</span>:<span class="string">"TextField1"</span>&#125;</span><br><span class="line">[<span class="keyword">debug</span>] [JSONWP Proxy] Got response with status <span class="number">200</span>: &#123;<span class="string">"value"</span>:&#123;<span class="string">"ELEMENT"</span>:<span class="string">"A3063789-1A9E-4FA2-A645-F2E257F0BB30"</span>&#125;,<span class="string">"sessionId"</span>:<span class="string">"95403F32-CD9B-4A0E-AA89-4BE9C899FBBC"</span>,<span class="string">"status"</span>:<span class="number">0</span>&#125;</span><br><span class="line">[<span class="keyword">debug</span>] [MJSONWP] Responding <span class="keyword">to</span> client with driver.findElement() resul<span class="variable">t:</span> &#123;<span class="string">"ELEMENT"</span>:<span class="string">"A3063789-1A9E-4FA2-A645-F2E257F0BB30"</span>&#125;</span><br><span class="line">[HTTP] &lt;-- POST /wd/hub/session/<span class="number">8790</span>f1db-<span class="number">9627</span>-<span class="number">41</span><span class="keyword">ce</span>-a534-bc40159c7194/element <span class="number">200</span> <span class="number">83</span> ms - <span class="number">122</span></span><br></pre></td></tr></table></figure></p><p>客户端再次传来请求，以下都是重复请求与返回，直到客户端传来删除会话。<br>当客户端单个任务执行完毕时，客户端传来删除会话，通讯与其它没有什么差别。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[HTTP] <span class="comment">--&gt; DELETE /wd/hub/session/5469f63c-9b2b-4a3a-bbdb-fa26bd6315f9 &#123;&#125;</span></span><br><span class="line">[debug] [MJSONWP] Calling AppiumDriver.deleteSession() with args: ["5469f63c-9b2b-4a3a-bbdb-fa26bd6315f9"]</span><br><span class="line">[debug] [BaseDriver] Event 'quitSessionRequested' logged at 1516514455122 (14:00:55 GMT+0800 (CST))</span><br><span class="line">[Appium] Removing session 5469f63c-9b2b-4a3a-bbdb-fa26bd6315f9 from our master session list</span><br><span class="line">[debug] [JSONWP Proxy] Proxying [<span class="keyword">DELETE</span> /<span class="keyword">session</span>/<span class="number">5469</span>f63c<span class="number">-9</span>b2b<span class="number">-4</span>a3a-bbdb-fa26bd6315f9] <span class="keyword">to</span> [<span class="keyword">DELETE</span> <span class="keyword">http</span>://localhost:<span class="number">8100</span>/<span class="keyword">session</span>/E9944FDA<span class="number">-46</span>DC<span class="number">-48</span>B4<span class="number">-824</span>B-A2C99D0B3BD2] <span class="keyword">with</span> <span class="keyword">no</span> <span class="keyword">body</span></span><br><span class="line">[debug] [JSONWP Proxy] Got response <span class="keyword">with</span> <span class="keyword">status</span> <span class="number">200</span>: <span class="string">"&#123;\n  \"value\" : &#123;\n\n  &#125;,\n  \"sessionId\" : \"334D0B8A-6B9E-4BAA-9BDA-BFEE66EBB584\",\n  \"status\" : 0\n&#125;"</span></span><br><span class="line">[debug] [XCUITest] <span class="keyword">Not</span> clearing <span class="keyword">log</span> files. <span class="keyword">Use</span> <span class="string">`clearSystemFiles`</span> capability <span class="keyword">to</span> turn on.</span><br><span class="line">[debug] [iOSLog] Stopping iOS <span class="keyword">log</span> capture</span><br><span class="line">[debug] [BaseDriver] <span class="keyword">Event</span> <span class="string">'quitSessionFinished'</span> logged <span class="keyword">at</span> <span class="number">1516514455352</span> (<span class="number">14</span>:<span class="number">00</span>:<span class="number">55</span> GMT+<span class="number">0800</span> (CST))</span><br><span class="line">[debug] [MJSONWP] Received response: <span class="literal">null</span></span><br><span class="line">[debug] [MJSONWP] But deleting <span class="keyword">session</span>, so <span class="keyword">not</span> <span class="keyword">returning</span></span><br><span class="line">[debug] [MJSONWP] Responding <span class="keyword">to</span> <span class="keyword">client</span> <span class="keyword">with</span> driver.deleteSession() <span class="keyword">result</span>: <span class="literal">null</span></span><br><span class="line">[<span class="keyword">HTTP</span>] &lt;<span class="comment">-- DELETE /wd/hub/session/5469f63c-9b2b-4a3a-bbdb-fa26bd6315f9 200 231 ms - 76</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Appium源码目录说明</title>
      <link href="/2018/01/29/201801291522/"/>
      <url>/2018/01/29/201801291522/</url>
      <content type="html"><![CDATA[<p>Appium版本 1.7.2<br>Appium源码主要由appium的入口文件js及一些引用的基础类库组成，以下举例说明源码目录大致功能，对于类库以appium-base-driver为例，类库中源码整体结构基本一致。</p><h4 id="appium文件夹下内容"><a href="#appium文件夹下内容" class="headerlink" title="appium文件夹下内容"></a>appium文件夹下内容</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">├── AUTHORS</span><br><span class="line">├── CHANGELOG.md</span><br><span class="line">├── CONDUCT.md</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── GOVERNANCE.md</span><br><span class="line">├── IDEAS.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── RELEASE.pdf</span><br><span class="line">├── ROADMAP.md</span><br><span class="line">├── build<span class="comment">//打包后生成的文件夹</span></span><br><span class="line">├── node_modules<span class="comment">//引用的类库文件夹</span></span><br><span class="line">├── docs<span class="comment">//文档文件夹</span></span><br><span class="line">├── commands-yml<span class="comment">//文档相关文件夹</span></span><br><span class="line">├── bin</span><br><span class="line">│   └── ios-webkit-debug-proxy-launcher.js</span><br><span class="line">├── gulpfile.js<span class="comment">//程度打包文件</span></span><br><span class="line">├── lib<span class="comment">//主程序执行入口</span></span><br><span class="line">│   ├── appium<span class="selector-class">.js</span> <span class="comment">//</span></span><br><span class="line">│   ├── config.js<span class="comment">//基础配置相关</span></span><br><span class="line">│   ├── grid-register.js</span><br><span class="line">│   ├── logger.js<span class="comment">//日志</span></span><br><span class="line">│   ├── logsink.js<span class="comment">//日志</span></span><br><span class="line">│   ├── main<span class="selector-class">.js</span> <span class="comment">//程序执行入口</span></span><br><span class="line">│   ├── parser<span class="selector-class">.js</span> <span class="comment">//appium终端命令相关js</span></span><br><span class="line">│   └── utils.js<span class="comment">//基础类库</span></span><br><span class="line">├── npm-shrinkwrap.json</span><br><span class="line">├── package.json</span><br><span class="line">├── packweb.json</span><br><span class="line">└── triagers.json</span><br></pre></td></tr></table></figure><h4 id="基础类库appium-base-driver"><a href="#基础类库appium-base-driver" class="headerlink" title="基础类库appium-base-driver"></a>基础类库appium-base-driver</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── build<span class="comment">//打包后生成的文件夹</span></span><br><span class="line">├── node_modules<span class="comment">//引用的类库文件夹</span></span><br><span class="line">├── docs<span class="comment">//文档文件夹</span></span><br><span class="line">├── gulpfile.js<span class="comment">//gulp打包文件</span></span><br><span class="line">├── index.js<span class="comment">//程序入口</span></span><br><span class="line">├── lib<span class="comment">//主要执行代码文件夹</span></span><br><span class="line">│   ├── basedriver</span><br><span class="line">│   │   ├── README.md</span><br><span class="line">│   │   ├── capabilities.js<span class="comment">//配置文件</span></span><br><span class="line">│   │   ├── commands</span><br><span class="line">│   │   │   ├── find.js</span><br><span class="line">│   │   │   ├── index.js</span><br><span class="line">│   │   │   ├── session.js<span class="comment">//客户端与服务端创建sessionId</span></span><br><span class="line">│   │   │   ├── settings.js</span><br><span class="line">│   │   │   └── timeout.js</span><br><span class="line">│   │   ├── desired-caps.js</span><br><span class="line">│   │   ├── device-settings.js</span><br><span class="line">│   │   ├── driver.js<span class="comment">//基础类库</span></span><br><span class="line">│   │   ├── helpers.js</span><br><span class="line">│   │   └── logger.js</span><br><span class="line">│   ├── express</span><br><span class="line">│   │   ├── README.md</span><br><span class="line">│   │   ├── crash.js</span><br><span class="line">│   │   ├── express-logging.js</span><br><span class="line">│   │   ├── logger.js</span><br><span class="line">│   │   ├── middleware.js<span class="comment">//中间件</span></span><br><span class="line">│   │   ├── server.js<span class="comment">//appium服务启动</span></span><br><span class="line">│   │   └── static.js</span><br><span class="line">│   ├── jsonwp-proxy</span><br><span class="line">│   │   ├── README.md</span><br><span class="line">│   │   └── proxy.js<span class="comment">//服务端与设备端通信</span></span><br><span class="line">│   ├── jsonwp-status</span><br><span class="line">│   │   ├── README.md</span><br><span class="line">│   │   └── status.js<span class="comment">//遵循json wire protocal的code返回值 </span></span><br><span class="line">│   └── mjsonwp</span><br><span class="line">│       ├── README.md</span><br><span class="line">│       ├── errors.js</span><br><span class="line">│       ├── helper.js</span><br><span class="line">│       ├── index.js</span><br><span class="line">│       ├── mjsonwp.js<span class="comment">//接收客户端res并返回res</span></span><br><span class="line">│       ├── routes.js<span class="comment">//路由配置</span></span><br><span class="line">│       ├── validators.js<span class="comment">//参数验证</span></span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── static<span class="comment">//静态资源</span></span><br><span class="line">└── test<span class="comment">//测试用例</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于源码分析Appium服务端启动过程</title>
      <link href="/2018/01/18/201801182037/"/>
      <url>/2018/01/18/201801182037/</url>
      <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>本文档主要是通过断点跟踪对于Appium源码，从而记录的Appium服务端的启动过程，如有错误或者理解不当之处，欢迎评论提出。<br>Appium版本：1.7.2 客户端  appium-python-client  2018年1月<br>可以直接看结论，根据结论中的关键js文件即可断点跟踪出全过程。</p><h4 id="appium文档"><a href="#appium文档" class="headerlink" title="appium文档"></a>appium文档</h4><p><a href="https://github.com/appium" target="_blank" rel="noopener">github</a></p><p><a href="http://appium.io/" target="_blank" rel="noopener">官方网站</a></p><h3 id="主体结构"><a href="#主体结构" class="headerlink" title="主体结构"></a>主体结构</h3><p><img src="http://upload-images.jianshu.io/upload_images/1094385-50476463c0d726b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方图片"><br>首先是官方这张图片，这张图片简直涵盖appium所有知识点！而且对于这张图片还有中文的readme！<br><a href="https://github.com/appium/appium/blob/master/docs/cn/contributing-to-appium/appium-packages.md" target="_blank" rel="noopener">中文readme直通车</a><br>图上分类很清晰 基本上以appium为前缀的都被封装成了类库，通过npm加载，在node_modules中如下图所示，其中appium-base-driver为整个服务的基础类库。上图所示的 <code>jsonwp-proxy</code>、<code>mobile-json-wire-protocal</code>等都在里面。<br><img src="http://upload-images.jianshu.io/upload_images/1094385-aba2f76c6e89ea0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="node的express"><a href="#node的express" class="headerlink" title="node的express"></a>node的express</h3><p>appium的服务端采用的是express框架，<a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">express中文文档</a>，如果之前用express建立过项目的话，会对express中的路由比较熟悉，很多时候路由的处理大概像<a href="http://blog.csdn.net/itfootball/article/details/44707431" target="_blank" rel="noopener">Appium源码分析(3)-路由器模块</a>这样列出来的样子，即通过<code>rest.get(&#39;/wd/hub/status&#39;, controller.getStatus);</code>该种方式可以查看到所有路由的处理，但是到今年18年appium的代码它的路由配置经过了层层调用。</p><p>而且作为node服务之前比较习惯入口的app.js即作为服务开启，但是在appium中它将该入口作为express模块直接放在了<code>appium-base-driver</code>中，也就是说appium源码的main入口并不是服务入口，那么他们之间的关系是一个怎样的继承及调用呢？</p><h3 id="源码目录分析"><a href="#源码目录分析" class="headerlink" title="源码目录分析"></a>源码目录分析</h3><p>假设我们想实现一个与客户端通讯的服务，那么主要包括服务开启、客户端http请求，响应函数，那么在appium中我们将其细化一下，大概是</p><blockquote><p>开启服务-&gt;客户端传来请求-&gt;开启当前测试用例会话-&gt;根据配置确定ios、android等-&gt;分别处理ios或安卓请求-&gt;ios或安卓返回后-&gt;响应客户端吧-&gt;关闭会话。</p></blockquote><p>首先看入口结构：</p><p><img src="http://upload-images.jianshu.io/upload_images/1094385-3dfc475124e93591.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180118-194031.png"></p><ul><li>build工程打包后出现的文件 程序执行来源于build中的main.js ,基本是对lib文件夹下通过babel对于代码进行的转换，所以调试的时候建议根据main.js调试</li><li>config.js 配置文件</li><li>logger.js 日志处理</li><li>parser.js 终端命令的处理</li><li>utils.js 基础函数<br>main.js 中除了启动的一些检查，重点代码在于<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; server <span class="keyword">as</span> baseServer &#125; <span class="keyword">from</span> <span class="string">'appium-base-driver'</span>;</span><br><span class="line"><span class="keyword">let</span> router = getAppiumRouter(args);<span class="comment">//该函数来源于appium.js</span></span><br><span class="line">  <span class="comment">//此处router返回的是个函数  用于装填路由路径 该函数执行路径位于/mjsonwp/mjsonwp.js 中routeConfiguringFunction 的返回函数</span></span><br><span class="line">  <span class="comment">//baseServer执行之后服务开始启动</span></span><br><span class="line"><span class="keyword">let</span> server = <span class="keyword">await</span> baseServer(router, args.port, args.address);</span><br></pre></td></tr></table></figure></li></ul><p>这两行代码可nb厉害了……就这两行基本就把基础类库溜了一圈！代码都是几行几行的，然后一调就转一大圈<br>在appium.js中我们找到了以下函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BaseDriver, routeConfiguringFunction, errors,</span><br><span class="line">         isSessionCommand, processCapabilities &#125; <span class="keyword">from</span> <span class="string">'appium-base-driver'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAppiumRouter</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> appium = <span class="keyword">new</span> AppiumDriver(args);<span class="comment">//实例化的这个类继承了appium-base-driver！</span></span><br><span class="line">  <span class="keyword">return</span> routeConfiguringFunction(appium);<span class="comment">//这个函数来自于appium-base-driver </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此成功引入基础类库<code>appium-base-driver</code>，然后就去那里翻吧</p><h4 id="基础类库appium-base-driver"><a href="#基础类库appium-base-driver" class="headerlink" title="基础类库appium-base-driver"></a>基础类库appium-base-driver</h4><p><img src="http://upload-images.jianshu.io/upload_images/1094385-7201454a76fa3ac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="没截全的地方都是配置"><br>画出的几个红框基本就是代码功能分类，其中<code>jsonwp-proxy</code>和<code>mjsonwp</code>是和协议相关，由于我不是很了解，所以不做介绍，只说明其中代码位置。<br>上边提到代码转向<code>routeConfiguringFunction</code></p><h4 id="routeConfiguringFunction"><a href="#routeConfiguringFunction" class="headerlink" title="routeConfiguringFunction"></a>routeConfiguringFunction</h4><p>这出自<code>mjsonwp/mjsonwp.js</code>，<strong>请牢牢的记住这个返回函数！！！</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">routeConfiguringFunction</span> (<span class="params">driver</span>) </span>&#123;</span><br><span class="line"><span class="comment">//...省略一些</span></span><br><span class="line">  <span class="comment">// return a function which will add all the routes to the driver</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [path, methods] <span class="keyword">of</span> _.toPairs(METHOD_MAP)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> [method, spec] <span class="keyword">of</span> _.toPairs(methods)) &#123;</span><br><span class="line">        <span class="comment">// set up the express route handler</span></span><br><span class="line">        buildHandler(app, method, path, spec, driver, isSessionCommand(spec.command));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它返回了一个函数并且里面还传参了<code>app</code>,之前断点打到这里时满脑子都是<strong>我是谁，我在哪里，我要干什么</strong><br>我们把代码往上看一下<code>routeConfiguringFunction</code>的返回值返回给<code>getAppiumRouter</code>再返回给let router  然后再传给baseServer（怪我不好好学js……看个代码艰辛非常……）<br>那么baseServer来自哪里呢？看import，它来自appium-base-server!<br><strong>main.js中调用了一圈再次进入appium-base-server</strong></p><h4 id="express中的server-js"><a href="#express中的server-js" class="headerlink" title="express中的server.js"></a>express中的server.js</h4><p>之前说到要去找baseServer来自哪里，终于在express/server.js中找到了  就是appium的http服务启动的地方！所以说服务开启的地方不在外部！在基础类库里啊！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">server</span> (<span class="params">configureRoutes, port, hostname = null</span>) </span>&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="comment">//里面有这样的代码</span></span><br><span class="line">configureServer (app, configureRoutes) &#123;</span><br><span class="line"><span class="comment">//然后再该函数中调用了</span></span><br><span class="line">  configureRoutes(app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以代码走到这里执行的就是那个返回函数，app是express的实例！那么执行这一步是为了做什么呢？这个<code>METHOD_MAP</code>是最大的全路由配置！来自于<code>mjsonwp/routes.js</code>,其中500行都是路由配置，经过该配置有效避免批量写<code>app.get()//balabala</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [path, methods] <span class="keyword">of</span> _.toPairs(METHOD_MAP)) &#123;</span><br><span class="line">  <span class="comment">//balabalbala</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>至此全路由配置装填结束！</p><h4 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h4><p>这个就没有什么波折了，既然server.js都找到了，就再这个文件中,看到这里终于看到了熟悉的node启动~<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let app</span> = express();</span><br><span class="line"><span class="attribute">let httpServer</span> = http.createServer(app);</span><br></pre></td></tr></table></figure></p><p>当断点跟到这里时终端就可以跳出如下输出,服务启动啦~<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Appium] Appium REST http<span class="built_in"> interface </span>listener started on 0.0.0.0:4723</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>启动服务执行过程<br><code>lib/main.js</code> 执行来自于<code>lib/appium.js</code>中的<code>getAppiumRouter</code>函数<br>该函数中实例化<code>AppiumDriver</code>类，同时读取路由配置文件，该类继承于<code>Appium-base-driver</code>库中暴露的基类，路由配置文件来源于<code>Appium-base-driver</code>库中<code>/mjsonwp/routes.js</code>的配置<br>配置文件读取之后在<code>/mjsonwp/mjsonwp.js</code>中以函数的形式返回<code>main.js</code> 执行<code>baseServer</code>函数  该函数来自于<code>Appium-base-driver/express/server.js</code></p><p>也就是说整个过程从</p><blockquote><p>main.js-[调用]-appium.js-[调用]-appium-base-driver/mjsonwp-[返回]-main.js-[调用]-appium-base-driver/express</p></blockquote><p>其实是通过层层调用将路由已配置的方式进行装填并在基础类库<code>appium-base-server</code>中启动</p>]]></content>
      
      
        <tags>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Appium在安卓上频繁安装unlock、setting.apk的问题查找记录</title>
      <link href="/2018/01/18/201801181414/"/>
      <url>/2018/01/18/201801181414/</url>
      <content type="html"><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>该问题已经被官方在1.7.x的版本中进行修复。以下为对于该问题的查找记录</p><h4 id="1-6-x版本说明"><a href="#1-6-x版本说明" class="headerlink" title="1.6.x版本说明"></a>1.6.x版本说明</h4><p>在appium1.6.x版本中 每次进行安卓用例测试时 appium都会安装unlock.app、setting.app、ime.app</p><p>关于这个的解决方式可参考如下blog</p><p><a href="http://blog.csdn.net/hszxd479946/article/details/78900982" target="_blank" rel="noopener">appium解决每次运行都需要安装Unlock以及AppiumSetting的问题</a></p><p>或者在appium设计到该处问题的源码位置，将其添加判断以上app是否安装的逻辑即可</p><h4 id="1-7-x版本说明"><a href="#1-7-x版本说明" class="headerlink" title="1.7.x版本说明"></a>1.7.x版本说明</h4><p>当前npm版本为1.7.2版本，官方已经修复了这个问题，在1.7.2的<a href="https://github.com/appium/appium/blob/master/CHANGELOG.md" target="_blank" rel="noopener">changeLog</a>中说明如下：<br><img src="http://upload-images.jianshu.io/upload_images/1094385-b33ef73da19de461.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">;</p><p>由于这个问题设计到的代码在appium-android-driver这个封装好的组件中，所以具体看一下是什么时候更改的,是在17年10月份的这次代码提交中修复了该问题。</p><p>从commit继续往下看，9月份这里也进行过改动，但是10月份改动之后与当前npm版本是一致的。<br><a href="https://github.com/appium/appium-android-driver/commit/033b70e75fcada83ff2e73e99d9c605c59b35621" target="_blank" rel="noopener">Fix handling of settings and unlock app pushing</a><br><img src="http://upload-images.jianshu.io/upload_images/1094385-8827acf34ec14ae1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>对于installOrUpgrade这个函数，它的定义在封装好的android-adb类库里面，那么接下来去这里看一下对于这个函数的更改。</p><p><a href="https://github.com/appium/appium-adb/commit/404455cf43e1f0086fa30d1ff6675f216f2e5a73" target="_blank" rel="noopener">android-adb commit</a></p><p>这个函数同样进行了两次更改，在9月份的更改中采用了外部传参的方式判断是否安装但是在10月份的commit中又去掉了外部传参的参数，改为在该函数中判断是否安装</p><p><img src="http://upload-images.jianshu.io/upload_images/1094385-c070ef3ec671314c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>对于这个的总结就是该问题已经被官方在1.7.x的版本中进行修复。</strong><br><strong>2018年1月</strong></p>]]></content>
      
      
        <tags>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Tesseract+python进行图片转文字记录</title>
      <link href="/2018/01/14/201801040223/"/>
      <url>/2018/01/14/201801040223/</url>
      <content type="html"><![CDATA[<h4 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h4><p>该blog完成于18年1月</p><p>先把Tesseract的基础部分放上来。</p><p>由于对游戏的文案非常感兴趣，所以希望可以将游戏中图片截图，识别图片上的文字转成txt，基于此记录一下学习过程，简单记录。</p><h4 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h4><p>Mac 10.13</p><p>python 2.7</p><p>Tesseract 3.05.01<a href="https://github.com/tesseract-ocr/tesseract/wiki" target="_blank" rel="noopener">github地址</a></p><p>因为对这些也不懂所以都是按照网上的教程来得</p><h4 id="英文识别"><a href="#英文识别" class="headerlink" title="英文识别"></a>英文识别</h4><p><code>Tesseract</code>github有安装教程。相关API参照<a href="https://www.polarxiong.com/archives/python-pytesser-tesseract.html" target="_blank" rel="noopener">Python:文本识别抛弃pytesser，直接使用Tesseract</a>，也就是说，当安装好后Tesseract之后，可以在终端直接操作</p><p>主要命令操作：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tesseract imagename outputbase <span class="string">[-l lang]</span> <span class="string">[-psm pagesegmode]</span> <span class="string">[configfile...]</span></span><br><span class="line"></span><br><span class="line">tesseract    图片名  输出文件名 -l 字库文件 -psm pagesegmode 配置文件</span><br><span class="line"></span><br><span class="line">-l后的字库文件可以切换为中文，默认是英文</span><br><span class="line">-psm是对于识别模式的一些设置</span><br></pre></td></tr></table></figure></p><p>按照wiki的说法<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract 图片路径   输出文件名<span class="comment">//eg:tesseract x.png out</span></span><br></pre></td></tr></table></figure></p><p>即可在终端对应目录下输出out.txt 里面是对文字的识别，按照如上试了以下两张图片<br><img src="http://upload-images.jianshu.io/upload_images/1094385-8fd43d8b9135462e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test.jpg"><br>这张图片的识别结果未成功，并未生产任何txt文件，终端报错如下<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tesseract Open Source OCR Engine v3<span class="number">.05</span><span class="number">.01</span> with Leptonica</span><br><span class="line">Warning. Invalid resolution <span class="number">0</span> dpi. Using <span class="number">70</span> instead.</span><br><span class="line"><span class="comment">//关于为什么会报这一行还没有查明白，因为发现无论成功与否都会报这一行</span></span><br><span class="line"><span class="comment">//简单搜索一下大概于tif什么之类的有关系，还没有查找</span></span><br></pre></td></tr></table></figure></p><p>当换成另一张图片<img src="http://upload-images.jianshu.io/upload_images/1094385-4c0919c8b4b2228b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4979037-c4469cd2356e5a06.jpg"></p><p>识别且产生txt，内容如下<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Y<span class="string">" ‘ WWIHBNEISM H8 3</span></span><br><span class="line"></span><br><span class="line">ORGAN</span><br><span class="line">NICHOLSON FREEMAN</span><br><span class="line">MUM’VHHIIV-HUN’N/DﬂmhnAMENUMMME UWUFDW WM TIFEUEKEMT A</span><br><span class="line">¢ WWW!“ HUBEEWWMWFW .</span><br><span class="line">zzrmmn Jmmmu JWMHH ‘ ,</span><br><span class="line">mum _. v _ mm“</span><br><span class="line">now</span><br></pre></td></tr></table></figure></p><p>从以上看出，识别还是要看图片背景等，在tesseract总默认是英文识别，且涉及到参数psm的问题，关于参数psm请在终端直接输入<code>tesseract</code><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Page segmentation modes:</span><br><span class="line">  0    Orientation <span class="keyword">and</span><span class="built_in"> script </span>detection (OSD) only.</span><br><span class="line">  1    Automatic<span class="built_in"> page </span>segmentation with OSD.</span><br><span class="line">  2    Automatic<span class="built_in"> page </span>segmentation, but <span class="literal">no</span> OSD, <span class="keyword">or</span> OCR.</span><br><span class="line">  3    Fully automatic<span class="built_in"> page </span>segmentation, but <span class="literal">no</span> OSD. (Default)</span><br><span class="line">  4    Assume a single column of text of variable sizes.</span><br><span class="line">  5    Assume a single uniform block of vertically aligned text.</span><br><span class="line">  6    Assume a single uniform block of text.</span><br><span class="line">  7    Treat the image as a single text line.</span><br><span class="line">  8    Treat the image as a single word.</span><br><span class="line">  9    Treat the image as a single word <span class="keyword">in</span> a circle.</span><br><span class="line"> 10    Treat the image as a single character.</span><br><span class="line"> 11    Sparse text. <span class="builtin-name">Find</span> as much text as possible <span class="keyword">in</span> <span class="literal">no</span> particular order.</span><br><span class="line"> 12    Sparse text with OSD.</span><br><span class="line"> 13   <span class="built_in"> Raw </span>line. Treat the image as a single text line,</span><br><span class="line">bypassing hacks that are Tesseract-specific.</span><br></pre></td></tr></table></figure></p><p>初步的文字识别还是ok的，因为最终要的结果是中文识别，所以要看一下如何进行中文识别。</p><h4 id="中文识别"><a href="#中文识别" class="headerlink" title="中文识别"></a>中文识别</h4><p>tesseract提供了中文的文字识别，下载地址<a href="https://github.com/daheicode/chi_sim" target="_blank" rel="noopener">https://github.com/daheicode/chi_sim</a><br>下载之后将<code>chi_sim.traineddata</code>文件拷贝到中文文件存放地址：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/usr/</span>local/Cellar<span class="meta-keyword">/tesseract/</span><span class="number">3.05</span><span class="number">.01</span><span class="meta-keyword">/share/</span>tessdata</span><br><span class="line"><span class="comment">//我在mac上存放到这里时有效的，如果无效就需要再查查了</span></span><br><span class="line"><span class="comment">//这个文件进去后可以看到英文的识别文件`eng.traineddata`）</span></span><br></pre></td></tr></table></figure></p><p>开启终端进行中文文字识别<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tesseract</span> 输入图片路径 -l chi_sim 输出文件名字</span><br></pre></td></tr></table></figure></p><p>这里测试了一下，识别结果一言难尽吧，对于阴阳师的传记识别很差，周围有一些文字进行干扰<br><img src="http://upload-images.jianshu.io/upload_images/1094385-3df4b477c29797e8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片j"><br>如果对于图片进行裁剪到如下程度<img src="http://upload-images.jianshu.io/upload_images/1094385-ac6362b56cdf2e5e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="x.jpeg"><br>识别结果是很一言难尽的，。这个结果的误差率挺高的。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">待<span class="number">1</span>己二 lw</span><br><span class="line"></span><br><span class="line">桢言宛一次出现耱诀盯町倪 衅</span><br><span class="line">也只是笑笑、 并没有责怪这个骧子</span><br><span class="line">D 但是幔憧地. 贵怪也开始了' 篷</span><br><span class="line">篝还有打骂. 骥子的靴上遍布伤痕</span><br><span class="line"></span><br><span class="line">害怕受列惩罚的孩子. 哭*预知著</span><br><span class="line">一切. 预言却还是耧未趟不准口</span><br><span class="line">终于. 有人操乱 这孜子既然己经</span><br><span class="line">失去T倾知的能九 不如就放弄这</span><br><span class="line">个孩子, 将他献给淹礼 或许还能</span><br><span class="line">平息灾祝 纂一次听到这个提议时.</span><br><span class="line">人<span class="number">4</span>ﬂ纷汾反对, 认为这对璩子太瀵</span><br><span class="line">忍了口 可是巢二炎 第三次的时伉</span><br><span class="line">反对的人罐毅赭叽</span><br></pre></td></tr></table></figure></p><p>尝试了一下微博的截图<br><img src="http://upload-images.jianshu.io/upload_images/1094385-b995d45c3ada0e1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="t.png"><br>结果为<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">全球健身中心-喧</span><br><span class="line"><span class="number">11</span>分钟前来目 微博淝伽咖</span><br><span class="line">拿去参考-下<span class="number">0</span></span><br><span class="line"></span><br><span class="line">@全球装饰大全 - 甜</span><br><span class="line">我敢说这是我见过最漂亮最实用的室内设计了,绝对没有比这更简美了.迸门就是原木地板,</span><br><span class="line">客厅就简单的布艺沙发搭配原木电器柜.迸门两边做的是嵌入式柜体,牧纳更是做到了极致;</span><br><span class="line">住在这样纯夫然酌冢里简直不要不要的m 喜欢就关注@全球装饰大全 胗微博全景图片</span><br><span class="line"></span><br><span class="line">〕</span><br><span class="line"></span><br><span class="line">微博全景图片</span><br><span class="line">我敢说这是我见过最室内设计了, 绝对没有比这更简美了° 布艺沙发</span><br><span class="line">搭配原木电器柜° 迸门两边做的是嵌入式柜体, 底面整体原木地板,</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>分钟前 来自 微博 weibo.oom 区 <span class="number">97</span> 臼 <span class="number">6</span> 凸 <span class="number">35</span></span><br></pre></td></tr></table></figure></p><p>到这里看一下我自己的需求是可以将图片中的文字转换，而且需求图片没有阴阳师背景那么杂乱，所以转换结果很好，因此没有继续看如何提高识别准确度。<br>这里一直讲的是通过终端进行图片转文字。但其实最后是通过python调用的Tesseract</p><h4 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h4><p>未完待续<br>python控制安卓截图=&gt;截图后裁图到合适区域=》图片转换文字存储=》模拟点击进行下一页面  【循环此过程】<br>（循环过程还没写 程序大概就是借鉴跳一跳的那个来~~~毕竟还不会python……）</p><h4 id="后续添加"><a href="#后续添加" class="headerlink" title="后续添加"></a>后续添加</h4><p>现在在18年的6月把这个补一下后续，关于识别游戏中的文案，采用了python控制安卓截图，但是再图片转换文字的时候调用了百度开放的图片转文字接口，每天免费500次，精确度非常高~整理起来特别爽~</p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于Appium+WDA+Python搭建IOS自动化测试全纪录(三):真机demo运行</title>
      <link href="/2018/01/10/201801102318/"/>
      <url>/2018/01/10/201801102318/</url>
      <content type="html"><![CDATA[<h4 id="前期回顾："><a href="#前期回顾：" class="headerlink" title="前期回顾："></a>前期回顾：</h4><p><a href="/2018/01/10/201801102040/">基于Appium+WDA+Python搭建IOS自动化测试全纪录(一):环境搭建</a></p><p><a href="/2018/01/10/201801102318/">基于Appium+WDA+Python搭建IOS自动化测试全纪录(二):模拟器demo运行</a></p><p>在模拟器将demo跑通之后，就要在真机上测试啦，模拟器总是要为真机服务的。</p><h4 id="证书问题"><a href="#证书问题" class="headerlink" title="证书问题"></a>证书问题</h4><p>在真机上主要是涉及到签名及证书的问题详解见如下blog<br><a href="http://blog.cnbang.net/tech/3386/" target="_blank" rel="noopener">iOS App 签名的原理</a></p><p>主要在此简单记录一下证书的配置吧。</p><p>在xcode中找到build Setting配置部分（之所以把这张图放出来是因为我最开始找不到这个配置，萌新啥都找不到）：<br><img src="http://upload-images.jianshu.io/upload_images/1094385-1ad7fd8414daedc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180115-203847@2x.png"></p><p>更改一下三个字段对应的内容：<br> Code Siging identify  证书里面对应的开发者<br>Product Bundle Identify  对应的bundleID<br>Provisioning Profile    包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。<br>数据包是.mobileprovision文件格式结尾  在终端中输入如下命令即可看到里面的信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">security cms -D -<span class="selector-tag">i</span> xxxxx.mobileprovision</span><br></pre></td></tr></table></figure><p>改完之后 我们开发的程度就可以装到真机上啦，这个时候选择在真机上运行，就可以啦。</p><h4 id="Appium中wda真机配置"><a href="#Appium中wda真机配置" class="headerlink" title="Appium中wda真机配置"></a>Appium中wda真机配置</h4><p>测试app装到真机上之后，还要考虑如何开启py脚本，在真机上进行测试。<br>这里需要注意两点：</p><ul><li>webDriverAgent的配置</li><li>py脚本的配置有变化</li></ul><p>关于WebDriverAgent<a href="https://github.com/facebook/WebDriverAgent" target="_blank" rel="noopener">github地址</a>这个还没了解太多，所以在这里先不介绍了。简单来说appium的服务中带有webDriverAgent，在模拟器上我们开启appium服务，会发现模拟机上会同步装上WebRriverAgentRunner的app，这个是appium能在ios上测试的关键条件，但是在真机上，却不能直接装上。<br><strong>因为需要证书啊！！！</strong></p><p>不能直接从github上下载进行证书配置，要改appium中node_modules中的webDriverAgent。</p><p>先找到appium的位置<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find</span> <span class="regexp">/ -name appium   /</span><span class="regexp">/ /u</span>sr<span class="regexp">/local/</span>lib<span class="regexp">/node_modules/</span>appium</span><br></pre></td></tr></table></figure></p><p>最后找到的地址大概如下：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">node_modules</span>/<span class="title">appium</span>/<span class="title">node_modules</span>/<span class="title">appium</span>-<span class="title">xcuitest</span>-<span class="title">driver</span>/<span class="title">WebDriverAgent</span></span></span><br></pre></td></tr></table></figure></p><p>放到xcode中进行签名证书配置，注意虽然我们打开的是WebDriverAgent文件夹，但是我们要配置的是WebdDriverAgentRunner  在其Build Settings中进行与证书有关的配置<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Code Siging identify  证书里面对应的开发者</span><br><span class="line">Product Bundle Identify  对应的bundleID</span><br><span class="line">Provisioning<span class="built_in"> Profile </span>   包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。</span><br></pre></td></tr></table></figure></p><p>配置完毕后还需要再WebdDriverAgentRunner中添加一个RoutingHTTPServer.frameork<br><img src="http://upload-images.jianshu.io/upload_images/1094385-8559492188f853ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180115-222415@2x.png"><br>点击添加之后-&gt;add Other<br>在如下路径可以查找到该framework<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">node_modules</span>/<span class="title">appium</span>/<span class="title">node_modules</span>/<span class="title">appium</span>-<span class="title">xcuitest</span>-<span class="title">driver</span>/<span class="title">WebDriverAgent</span>/<span class="title">Carthage</span>/<span class="title">Build</span>/<span class="title">iOS</span></span></span><br></pre></td></tr></table></figure></p><p>找的一定是appium文件路径下的！上边关于wda并没有做过多说明，因为还不怎么了解~等了解了再补充相关知识~</p><h4 id="py脚本"><a href="#py脚本" class="headerlink" title="py脚本"></a>py脚本</h4><p>py脚本主要是配置有更改，主体文件请见开头（二）模拟器demod的blog<br>在真机上配置更改如下：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">desired_capabilities=&#123;</span><br><span class="line">               <span class="string">'bundleId'</span>: <span class="comment">//这个是和证书有关联的</span></span><br><span class="line">               <span class="string">'platformName'</span>: <span class="string">'iOS'</span>,</span><br><span class="line">               <span class="string">'platformVersion'</span>: <span class="string">'9.3.2'</span>,</span><br><span class="line">               <span class="string">'deviceName'</span>: <span class="string">'iPhone5 slave15'</span>,</span><br><span class="line">               <span class="string">'automationName'</span>:<span class="string">'XCUITest'</span>,</span><br><span class="line">               <span class="string">"clearSystemFiles"</span> : <span class="literal">True</span>,</span><br><span class="line">               <span class="string">'udid'</span>:<span class="comment">//模拟器的时候我们用uuid，但是真机上请用udid</span></span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure></p><p>然后启动appium 发现真机上装上了厕所app 装上了WebDriverAgentRunner   然后用python运行脚本就ok拉！</p><p>以上为从搭建环境-》模拟器跑demo-》真机跑demo的简单记录，不涉及到原理方面的讲解，如有错误之处还请提出。</p><p>[Tbc]</p>]]></content>
      
      
        <tags>
            
            <tag> Appium环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于Appium+WDA+Python搭建IOS自动化测试全纪录(二):模拟器demo运行</title>
      <link href="/2018/01/10/201801102224/"/>
      <url>/2018/01/10/201801102224/</url>
      <content type="html"><![CDATA[<p><a href="/2018/01/10/201801102040/">基于Appium+WDA+Python搭建IOS自动化测试全纪录(一):环境搭建</a></p><p>由于在跑这个demo之前，完全没有接触过移动端，就是连模拟器都不会启动的那种，所以步骤会说的比较啰嗦详细。</p><h4 id="如何跑测试DEMO"><a href="#如何跑测试DEMO" class="headerlink" title="如何跑测试DEMO"></a>如何跑测试DEMO</h4><p>选定测试用例,github提供了测试的explame</p><p><a href="https://github.com/appium/sample-code" target="_blank" rel="noopener">https://github.com/appium/sample-code</a></p><h4 id="代码选择"><a href="#代码选择" class="headerlink" title="代码选择"></a>代码选择</h4><p>需要选择一个ios的APP，一个python脚本，如图选择的是app里面的TestApp，脚本选择的是python里面的ios_sample.py<br><img src="http://upload-images.jianshu.io/upload_images/1094385-72611e445351abec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">;</p><h4 id="模拟器运行"><a href="#模拟器运行" class="headerlink" title="模拟器运行"></a>模拟器运行</h4><p>因为是在模拟器上运行，所以要先把app放到模拟器上。一般来说通过在xcode中运行代码就可在模拟器中生产app，但是这个TestApp用例进去看了之后发现里面如图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1094385-9a55f95dc9c13a23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>所以就只能开启模拟器，然后把右边红框框生产的app拖放到模拟器里。<br>想用命令行操作请看这里：<a href="https://www.jianshu.com/p/8edf0b4ffb1b" target="_blank" rel="noopener">iOS-通过命令行安装.app到模拟器https://www.jianshu.com/p/8edf0b4ffb1b</a></p><h4 id="配置更改"><a href="#配置更改" class="headerlink" title="配置更改"></a>配置更改</h4><p>现在app已经拖到模拟器里了，接下来启动python脚本，在执行脚本之前，还有一些配置需要更改。<br>如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/1094385-09190b669d9db567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180110-205552@2x.png"></p><p>首先说uuid的问题，每一个模拟器都有对应的uuid，这里在执行模拟器时用的是uuid，但是到了真机上，就变成了udid。</p><p><strong>所以要拿到当前模拟器的uuid：</strong></p><p>终端输入命令可得到想要的模拟器的字符串。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">instruments -s devices</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1094385-b0756ac60e6e89f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>所以配置信息多添加一行<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">'uuid</span><span class="symbol">':</span><span class="symbol">'xxxxxx</span>'</span><br></pre></td></tr></table></figure></p><p>更改后的配置如下：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">          desired_capabilities=&#123;</span><br><span class="line">                'app': app,</span><br><span class="line">                'platformName': 'iOS',</span><br><span class="line">                'platformVersion': '11.2',<span class="comment">//更改为当前模拟器的版本</span></span><br><span class="line">                'deviceName': 'iPhone 6s',<span class="comment">//更改为当前模拟器的型号 </span></span><br><span class="line">                'uuid':'2EF911A2-CA9C-4D28-96EB-3DBC8DF39FA5'<span class="comment">//更改为当前模拟器的uuid</span></span><br><span class="line"><span class="comment">//经过测试发现在模拟器上uuid不是必须的，所以这里不填也可正常运行</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure></p><h4 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h4><p>先启动appium<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">appium</span></span><br></pre></td></tr></table></figure></p><p>当控制台中显示如下，启动成功<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Appium] Welcome <span class="keyword">to</span> Appium v1.7.2</span><br><span class="line">[Appium] Appium REST http<span class="built_in"> interface </span>listener started on 0.0.0.0:4723</span><br></pre></td></tr></table></figure></p><p>在脚本所在目录下执行<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> xxxx.<span class="keyword">py</span></span><br></pre></td></tr></table></figure></p><p>（由于ios_sample.py的名字被用来测试别的了，所以给其改成了ios.py）<br><img src="http://upload-images.jianshu.io/upload_images/1094385-9cbb164e39d74e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如此，模拟器上测试demo运行成功！<br>由于是在整个流程跑通之后回头做的纪录，所以可能有些地方纪录不完善，错误之处欢迎提出。</p><hr><p>[Tbc]</p>]]></content>
      
      
        <tags>
            
            <tag> Appium环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于Appium+WDA+Python搭建IOS自动化测试全纪录(一):环境搭建</title>
      <link href="/2018/01/10/201801102040/"/>
      <url>/2018/01/10/201801102040/</url>
      <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>计划将整个自动化搭建过程全部纪录一下，从环境搭建到模拟器跑demo，到真机跑demo  </p><p>当前测试及环境跑通日期为2018.1月</p><p><strong>本文要点:</strong></p><ul><li>appium ios环境搭建  python环境搭建</li><li>Mac下 appium 1.7.2  python 2.7</li></ul><h4 id="appium环境搭建"><a href="#appium环境搭建" class="headerlink" title="appium环境搭建"></a>appium环境搭建</h4><ul><li><p>安装Xcode，安装xcode-command-line-tools</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">终端中输入以下命令：xcode-<span class="keyword">select</span> <span class="comment">--install</span></span><br></pre></td></tr></table></figure></li><li><p>安装brew</p><p>  <a href="https://brew.sh/" target="_blank" rel="noopener">官网地址</a></p><p>  终端中输入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/install)"</span></span><br></pre></td></tr></table></figure></li><li><p>安装libimobiledevice</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>libimobiledevice --HEAD</span><br></pre></td></tr></table></figure></li><li><p>安装carthage</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>carthage</span><br></pre></td></tr></table></figure></li><li><p>安装node <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官方的地址</a> 下载.pkg文件安装</p></li><li><p>安装cnpm</p></li></ul><p>安装cnpm(由于某种原因,直接用npm下载安装会有好多网络问题，安装淘宝的cnpm要比npm好用)<a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g cnpm --registry=https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure><ul><li><p>安装ios-deploy</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="keyword">install</span> -g ios-deploy</span><br></pre></td></tr></table></figure></li><li><p>安装xcpretty</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="keyword">install</span> xcpretty</span><br></pre></td></tr></table></figure></li><li><p>安装java环境</p></li></ul><p>(1)下载JAVA安装包：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>(2)配置JAVA_HOME环境：</p><p>在~/.bash_profile</p><p>修改如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home   </span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$JAVA_HOME</span>/bin:$PATH </span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">CLASSPATH</span>=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure></p><ul><li>安装appium，appium-doctor</li></ul><p>如果cnpm也卡了，想办法连vpn~<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="keyword">install</span> -g appium</span><br><span class="line">cnpm <span class="keyword">install</span> -g appium-doctor</span><br></pre></td></tr></table></figure></p><p>这之后执行appium-doctor<br>如果ios部分都变绿了就ok了。其中Android_Home,adb之类的变红是安卓的环境，对于ios没有什么影响。如果报错缺少了哪里的安装，直接搜安装方法就好。<br><img src="http://upload-images.jianshu.io/upload_images/1094385-fec7f2f94bbfc472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="Python环境搭建"><a href="#Python环境搭建" class="headerlink" title="Python环境搭建"></a>Python环境搭建</h4><p>由于采用Python来写自动化测试脚本，因此需要搭建Python的相关环境</p><p>采用了Python 2.7</p><p>使用pip方式安装<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>pip</span><br><span class="line">pip <span class="keyword">install </span>lxml</span><br></pre></td></tr></table></figure></p><p>安装Python-client<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> Appium-Python-<span class="keyword">Client</span></span><br></pre></td></tr></table></figure></p><p>搭建或者运行过程中出现xxx not defined  之类的，可能是模块缺失，查一下是哪些模块  补一下就好，由于是在整个流程跑通之后回头做的纪录，所以可能有些地方纪录不完善，错误之处欢迎提出。</p><p>那么环境搭建之后，通过启动app跑脚本即可达到流程跑通，所以接下来说如何跑脚本。</p><hr><p>[Tbc]</p>]]></content>
      
      
        <tags>
            
            <tag> Appium环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python爬取B站弹幕+R语言分词安装调试报错记录</title>
      <link href="/2017/09/03/201709031632/"/>
      <url>/2017/09/03/201709031632/</url>
      <content type="html"><![CDATA[<p><strong>环境说明：<br>windows8.1 x64+python3.6+scrapy1.4<br>window8.1 x64+R3.4.2+jiebaR插件+rJson插件+RStudio编辑器+wordcloud2插件</strong></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>以下所有问题答案均来源网络，在此整理并做记录。本文记录源于<a href="/2017/09/03/201709031514/">萌新学习Python爬取B站弹幕+R语言分词demo说明</a><br>建议结合食用，风味更佳</p><h3 id="python部分"><a href="#python部分" class="headerlink" title="python部分"></a>python部分</h3><h4 id="python安装过程中出现了当前程序已停止安装"><a href="#python安装过程中出现了当前程序已停止安装" class="headerlink" title="python安装过程中出现了当前程序已停止安装"></a>python安装过程中出现了当前程序已停止安装</h4><p>这个忘记截图了，就是在安装exe的过程中出现报错，安装成功后无法打开。后来查找到原因据说是进入python官网直接下的windows版本是32位的，当我找到64位时下载再安装就正常了。</p><h4 id="scrapy安装过程中报错Microsoft-Visual-C-14-0-is-required"><a href="#scrapy安装过程中报错Microsoft-Visual-C-14-0-is-required" class="headerlink" title="scrapy安装过程中报错Microsoft Visual C++ 14.0 is required."></a>scrapy安装过程中报错<code>Microsoft Visual C++ 14.0 is required.</code></h4><p>scrapy安装过程中报错如下：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">building 'twisted.test.raiser' extension</span><br><span class="line"><span class="keyword">error: </span>Microsoft Visual C++ 14.0 is required. Get it with "Microsoft Visual C++ Build Tools": http://landinghub.visualstudio.com/visual-cpp-build-tools</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1094385-167a042f16403743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>解决方式</strong><br><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</a><br>下载<strong><em>twisted</em></strong>对应版本的whl文件（如我的<code>Twisted‑17.5.0‑cp36‑cp36m‑win_amd64.wh</code>l，cp后面是python版本，amd64代表64位，运行命令：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">E</span>:\<span class="selector-tag">Twisted-17</span><span class="selector-class">.5</span><span class="selector-class">.0-cp36-cp36m-win_amd64</span><span class="selector-class">.whl</span></span><br></pre></td></tr></table></figure></p><p>然后再次执行<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> Scrapy</span><br></pre></td></tr></table></figure></p><h4 id="scrapy启动demo过程中报ModuleNotFoundError-No-module-named-39-win32api-39"><a href="#scrapy启动demo过程中报ModuleNotFoundError-No-module-named-39-win32api-39" class="headerlink" title="scrapy启动demo过程中报ModuleNotFoundError: No module named &#39;win32api&#39;"></a>scrapy启动demo过程中报<code>ModuleNotFoundError: No module named &#39;win32api&#39;</code></h4><p><a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/" target="_blank" rel="noopener">https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/</a><br>去这个网站下载对应的win32的软件</p><p><img src="http://upload-images.jianshu.io/upload_images/1094385-e4dd1fbbe58ecbf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="安装win32的时候报错如下"><a href="#安装win32的时候报错如下" class="headerlink" title="安装win32的时候报错如下"></a>安装win32的时候报错如下</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="built_in">version</span> <span class="number">3.6</span> required, which was <span class="keyword">not</span> found <span class="keyword">in</span> <span class="keyword">the</span> registry</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1094385-8b4a64231b55d8a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这个网上说是没有注册的问题，在网上找了一段代码<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">import sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    from winreg import *</span><br><span class="line">except ImportError:</span><br><span class="line">    from _winreg import *</span><br><span class="line"> </span><br><span class="line"># tweak <span class="keyword">as</span> necessary</span><br><span class="line"><span class="keyword">version</span> = sys.<span class="keyword">version</span>[:<span class="number">3</span>]</span><br><span class="line">installpath = sys.prefix</span><br><span class="line"> </span><br><span class="line">regpath = <span class="string">"SOFTWARE\\Python\\Pythoncore\\&#123;0&#125;\\"</span>.format(<span class="keyword">version</span>)</span><br><span class="line">installkey = <span class="string">"InstallPath"</span></span><br><span class="line">pythonkey = <span class="string">"PythonPath"</span></span><br><span class="line">pythonpath = <span class="string">"&#123;0&#125;;&#123;1&#125;\\Lib\\;&#123;2&#125;\\DLLs\\"</span>.format(</span><br><span class="line">    installpath, installpath, installpath)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def RegisterPy():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">reg</span> = OpenKey(HKEY_CURRENT_USER, regpath)</span><br><span class="line">    except EnvironmentError <span class="keyword">as</span> <span class="keyword">e</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">reg</span> = CreateKey(HKEY_CURRENT_USER, regpath)</span><br><span class="line">            SetValue(<span class="keyword">reg</span>, installkey, REG_SZ, installpath)</span><br><span class="line">            SetValue(<span class="keyword">reg</span>, pythonkey, REG_SZ, pythonpath)</span><br><span class="line">            CloseKey(<span class="keyword">reg</span>)</span><br><span class="line">        excep<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">print</span>(<span class="string">"*** Unable to register!"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"--- Python"</span>, <span class="keyword">version</span>, <span class="string">"is now registered!"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (QueryValue(<span class="keyword">reg</span>, installkey) == installpath <span class="built_in">and</span></span><br><span class="line">        QueryValue(<span class="keyword">reg</span>, pythonkey) == pythonpath):</span><br><span class="line">        CloseKey(<span class="keyword">reg</span>)</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"=== Python"</span>, <span class="keyword">version</span>, <span class="string">"is already registered!"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    CloseKey(<span class="keyword">reg</span>)</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"*** Unable to register!"</span>)</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"*** You probably have another Python installation!"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    RegisterPy()</span><br></pre></td></tr></table></figure></p><p>将代码保存成<code>register.py</code>，在该文件夹下执行<br> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> register.<span class="keyword">py</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1094385-86762400ebebee39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>问题解决</p><h3 id="R语言部分"><a href="#R语言部分" class="headerlink" title="R语言部分"></a>R语言部分</h3><h4 id="读取文件报错"><a href="#读取文件报错" class="headerlink" title="读取文件报错"></a>读取文件报错</h4><figure class="highlight plain"><figcaption><span>addition: Warning message:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In read.table(&quot;E:/danmu/2.txt&quot;, header = FALSE, ) :</span><br><span class="line">incomplete final line found by readTableHeader on &apos;E:/danmu/2.txt&apos;</span><br></pre></td></tr></table></figure><p>当时的txt文件时我自己写入的，问题可能出在文件的结尾没有空格上，我在文件的结尾加了空格就可以正常使用了（如果空格也不行，试试回车）</p><h4 id="调用wordcloud2函数时报错"><a href="#调用wordcloud2函数时报错" class="headerlink" title="调用wordcloud2函数时报错"></a>调用wordcloud2函数时报错</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error </span>in `[.data.frame`(data, , 1:2) : undefined columns selected</span><br></pre></td></tr></table></figure><p>这个问题我后来也没有解决，这个问题的上下文是<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">keys</span> = worker(<span class="string">"keywords"</span>,<span class="attr">topn=150)</span></span><br><span class="line"> <span class="attr">re</span> = vector_keywords(segment,keys)</span><br><span class="line"> wordcloud2(re, <span class="attr">size</span> = <span class="number">2</span>, <span class="attr">minRotation</span> = -pi/<span class="number">2</span>, <span class="attr">maxRotation</span> = -pi/<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>我这边猜测是jiebaR的<code>vector_keywords</code>函数返回的是向量，且输出的结果没有词频，当我把<code>freq(segment)</code>的结果传给<code>wordcloud</code>时就可以正常执行，此时<code>freq(segment)</code>的结果输出类型为<code>data.frame</code>，猜测如下：</p><ol><li>wordcloud接受的参数类型为data.frame 且需要有词频</li><li>wordcloud接受的参数类型不一定为data.frame 但一定需要有词频<br>词频是一定需要的，但是参数类型不确定，就因为<code>vector_keywords</code>的结果不知道怎么分出词频，才采用了<code>freq()</code>函数绘制词云。<br><img src="http://upload-images.jianshu.io/upload_images/1094385-2097f82d76c53959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20170903134316.png"></li></ol><p>跪求大佬指导如何用关键词绘制词云啊，我真的不知道这个生成的关键词怎么把词频和词分开！而且为什么把<code>vector_keywords</code>的结果转换成<code>list</code>类型或者<code>data.frame</code>类型词频就消失了呢！输出的.csv文件里还是没有词频啊！</p><h4 id="R语言的插件安装的意外顺利，就是360总是要阻止行为"><a href="#R语言的插件安装的意外顺利，就是360总是要阻止行为" class="headerlink" title="R语言的插件安装的意外顺利，就是360总是要阻止行为"></a>R语言的插件安装的意外顺利，就是360总是要阻止行为</h4><p>the end.</p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>萌新学习Python爬取B站弹幕+R语言分词demo说明</title>
      <link href="/2017/09/03/201709031514/"/>
      <url>/2017/09/03/201709031514/</url>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>之前在简书首页看到了Python爬虫的介绍，于是就想着爬取B站弹幕并绘制词云，因此有了这样一个简单的尝试，从搭建环境到跑通demo，不懂语法，不知含义，装好环境，查到API，跑通Demo，就是目标！纯零基础萌新！<br><a href="https://github.com/a67c/pyBilibilBarrage" target="_blank" rel="noopener">demo地址</a>(只有python的demo，R的没有上传)</p><p><a href="/2017/09/03/201709031632/">关于环境的安装及调试过程中遇到的问题记录请移步</a></p><h2 id="Python爬取B站弹幕"><a href="#Python爬取B站弹幕" class="headerlink" title="Python爬取B站弹幕"></a>Python爬取B站弹幕</h2><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><p><strong>windows8.1 x64+python3.6+scrapy1.4</strong></p><p>参考文档：</p><p><a href="https://github.com/scrapy/scrapy/blob/1.4/docs/topics/selectors.rst" target="_blank" rel="noopener">scrapy github</a></p><p><a href="https://doc.scrapy.org/en/latest/topics/selectors.html?highlight=extract" target="_blank" rel="noopener">scrapy document</a></p><p><a href="http://blog.csdn.net/zjiang1994/article/details/52779537" target="_blank" rel="noopener">scrapy爬虫框架入门实例</a></p><h3 id="步骤说明"><a href="#步骤说明" class="headerlink" title="步骤说明"></a>步骤说明</h3><ul><li>安装python3.6</li><li>安装scrapy1.4</li><li>建立scrapy demo</li><li>跑通demo遇到问题、解决问题</li><li>更改demo为B站弹幕爬取demo<br>我这边是按照参考文档中 <a href="http://blog.csdn.net/zjiang1994/article/details/52779537" target="_blank" rel="noopener">scrapy爬虫框架入门实例</a>这个demo来做的，这个文章里面无论是介绍还是<code>scrapy</code>的入门都非常详细，建议大家按照这个来入门，但是由于慕课网的结构样式以及更改了，所以demo是跑不起来的，因此我换成了爬取B站的弹幕demo。截止2017年9月2日亲测可跑通。</li></ul><h3 id="Demo说明"><a href="#Demo说明" class="headerlink" title="Demo说明"></a>Demo说明</h3><p><strong>1.  安装scrapy成功之后建立项目<code>scrapytest</code></strong><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">scrapy startproject scrapytest</span></span><br></pre></td></tr></table></figure></p><p><strong>2. demo目录</strong><br>本demo目录仅保留当前demo可用的文件，且文件名字不同于<code>scrapy</code>自动生成的文件名字，对于未涉及到的文件进行了删除<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">│  scrapy.cfg<span class="comment">//项目的配置文件</span></span><br><span class="line">└─scrapytest</span><br><span class="line">    │  CourseItems.py<span class="comment">//定义一个容器保存要爬取的数据</span></span><br><span class="line">    │  MyPipelines.py<span class="comment">//项目中的pipelines文件.</span></span><br><span class="line">    │  settings.py<span class="comment">//项目中的设置文件.</span></span><br><span class="line">    ├─spiders</span><br><span class="line">    │  │  <span class="keyword">data</span>.json<span class="comment">//爬取数据生成的文件</span></span><br><span class="line">    │  └─ Myspider.py<span class="comment">//爬虫主代码</span></span><br></pre></td></tr></table></figure></p><p><strong>3. demo代码</strong></p><p> <strong>创建CourseItems.py文件</strong><br>定义一个容器保存要爬取的数据。为了定义常用的输出数据，<code>Scrapy</code>提供了<code>Item</code>类。<code>Item</code>对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like)的API以及用于声明可用字段的简单语法。由于最后输出的只要弹幕的内容，所以容器中只定义了弹幕的内容</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#引入文件</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">CourseItem</span>(<span class="title">scrapy</span>.<span class="type">Item</span>):</span></span><br><span class="line"><span class="class">    #弹幕内容</span></span><br><span class="line"><span class="class">    content = scrapy.<span class="type">Field</span>()</span></span><br></pre></td></tr></table></figure><p> <strong>编写爬取代码Myspider.py</strong></p><ul><li>bilibili的弹幕是在xml文件里，每个视频都有其对应的cid和aid，我们取到cid中的数字放入<code>http://comment.bilibili.com/+cid+.xml</code>,即可得到该视频对应的cid。<br>cid取法：cid在源码中是没有找到的，目前我的做法是在页面上F12，然后查找cid，该cid即为弹幕页的标识，如果有可以通过代码查到的方法，还请告知。目前例子中的cid有1000多条弹幕，建议大家换个少的进行测试。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1094385-e060510f5149b12e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cid查找方法"></p><ul><li>弹幕的xml文件结构非常简单，所以通过Xpath简单解析即可</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1094385-27d44a81c00fc3cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="弹幕的xml文件结构"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="comment">#引入容器</span></span><br><span class="line"><span class="keyword">from</span> scrapytest.CourseItems <span class="keyword">import</span> CourseItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myspider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    <span class="comment">#设置name</span></span><br><span class="line">    name = <span class="string">"Myspider"</span> //启动项目时所用name</span><br><span class="line">    <span class="comment">#设定域名</span></span><br><span class="line">    allowed_domains = [<span class="string">"bilibili.com"</span>]</span><br><span class="line">    <span class="comment">#填写爬取地址</span></span><br><span class="line">    start_urls = [<span class="string">"http://comment.bilibili.com/2015358.xml"</span>]</span><br><span class="line">    <span class="comment">#编写爬取方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="comment">#实例一个容器保存爬取的信息</span></span><br><span class="line">        item = CourseItem()</span><br><span class="line">        <span class="comment">#这部分是爬取部分，使用xpath的方式选择信息，具体方法根据网页结构而定</span></span><br><span class="line">        <span class="comment">#直接爬取弹幕内容</span></span><br><span class="line">        str0 = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> box <span class="keyword">in</span> response.xpath(<span class="string">'/i/d/text()'</span>):</span><br><span class="line">            <span class="comment">#获取每一条弹幕内容</span></span><br><span class="line">            str0 += box.extract()+<span class="string">','</span>;</span><br><span class="line">            <span class="comment">#返回信息</span></span><br><span class="line">        item[<span class="string">'content'</span>] = str0;//最后输出的结构是值：字符串的结构，详细见输出图</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p><strong>编写MyPipelines.py处理数据</strong><br>当成功获取信息后，要进行信息的验证、储存等工作，这里只进行简单的将数据存储在json中的操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#引入文件</span></span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> DropItem</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#打开文件</span></span><br><span class="line">        self.file = open(<span class="string">'data.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#该方法用于处理数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="comment">#读取item中的数据</span></span><br><span class="line">        line = json.dumps(dict(item), ensure_ascii=<span class="keyword">False</span>) + <span class="string">"\n"</span></span><br><span class="line">        <span class="comment">#写入文件</span></span><br><span class="line">        self.file.write(line)</span><br><span class="line">        <span class="comment">#返回item</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    <span class="comment">#该方法在spider被开启时被调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">#该方法在spider被关闭时被调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p><strong>注册Pipeline</strong><br>找到<code>settings.py</code>文件,这个文件时爬虫的配置文件，在其中添加<br> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    'scrapytest.MyPipelines.MyPipeline': 300,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码用于注册<code>Pipeline</code>，其中<code>scrapytest.MyPipelines.MyPipeline</code>为你要注册的类，右侧的’300’为该<code>Pipeline</code>的优先级，范围1～1000，越小越先执行。(<em>ps：这个并没有详细了解</em>)<br><strong>4. 运行demo</strong><br>在<code>Myspider.py</code>的同级下执行cmd控制台，运行一下命令。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">scrapy crawl MySpider</span></span><br></pre></td></tr></table></figure></p><p><strong>5. 运行结果</strong><br>这是一个json的文件，json文件的输出结构更改在<code>Myspider.py</code>中，我改成这种通过逗号来连接每一条弹幕时是为了之后方便分词。大家也可以把代码改了改成另一种展示方式</p><p><img src="http://upload-images.jianshu.io/upload_images/1094385-3729642445b03ed2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="便于分词的展示方式"></p><p><img src="http://upload-images.jianshu.io/upload_images/1094385-074555839887ab2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="另一种方式"></p><h3 id="Python爬取end"><a href="#Python爬取end" class="headerlink" title="Python爬取end"></a>Python爬取end</h3><p>到此python爬取B站弹幕demo结束，接下来我们通过拿到的json文件去R语言中进行分词。</p><p>##R语言分词实例</p><h3 id="环境说明-1"><a href="#环境说明-1" class="headerlink" title="环境说明"></a>环境说明</h3><p><strong>window8.1 x64+R3.4.2+jiebaR插件+rJson插件+RStudio编辑器+wordcloud2插件</strong></p><p><a href="https://www.r-project.org/" target="_blank" rel="noopener">R语言官网</a></p><p><a href="https://www.rstudio.com/products/rstudio/download/" target="_blank" rel="noopener">Rstudio下载地址</a></p><p><a href="http://blog.fens.me/r-word-jiebar/" target="_blank" rel="noopener">R语言中文分司包jiabaR</a></p><p><a href="http://blog.fens.me/r-json-rjson/" target="_blank" rel="noopener">R和json的傻瓜式编程</a></p><p><a href="https://www.w3cschool.cn/r/r_overview.html" target="_blank" rel="noopener">R语言w3c教程</a></p><p><a href="http://qinwenfeng.com/jiebaR/section-1-1.html" target="_blank" rel="noopener">jiebaR中午分词文档</a></p><p><a href="https://github.com/Lchiffon/wordcloud2" target="_blank" rel="noopener">wordcloud2 gtihub</a></p><p><a href="http://www.cnblogs.com/nxld/p/6344233.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">R语言︱文本挖掘——词云wordcloud2包</a></p><h3 id="步骤说明-1"><a href="#步骤说明-1" class="headerlink" title="步骤说明"></a>步骤说明</h3><ul><li>安装R、Rstudio、jiebaR、rJSON</li><li>引入JSON文件</li><li>分词处理</li><li>停止词处理</li><li>过滤数字及字母</li><li>产生数据</li><li>调用wordcloud2绘制词云<br>关于<code>jiebaR</code>分词基本是按照<a href="http://blog.fens.me/r-word-jiebar/" target="_blank" rel="noopener">R语言中文分司包jiabaR</a>这个博客的demo来进行的。该博文中对于<code>jiebaR</code>的各种函数介绍的非常全面，因此下面demo将不对代码内容进行详细介绍。demo中的各种路径请自行更改。</li></ul><h3 id="demo说明"><a href="#demo说明" class="headerlink" title="demo说明"></a>demo说明</h3><p>只有一个jiebaR.R文件即完成了分词和绘制词云，代码如下：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#调入分词的库</span><br><span class="line">library(<span class="string">"jiebaR"</span>)</span><br><span class="line">library(<span class="string">"rjson"</span>)</span><br><span class="line"></span><br><span class="line">#这里读取的`python`爬取的`json`文件，拿道了对象中`content`键的值，该值是一长串字符串，在爬虫输出的时候通过逗号来连接字符串，因此分词时是通过逗号进行的分词</span><br><span class="line">myfile&lt;-fromJSON(file = <span class="string">"F:/gitlab/py/scrapytest/scrapytest/spiders/data.json"</span>)$content</span><br><span class="line"></span><br><span class="line">#预处理，这步可以将读入的文本转换为可以分词的字符，本demo通过逗号进行分词</span><br><span class="line"> myfile.res&lt;-myfile[myfile!=<span class="string">","</span>]</span><br><span class="line"></span><br><span class="line">#调用分词引擎worker函数  stop_word为停止词设置</span><br><span class="line">wk = worker(stop_word =<span class="string">'F:/R/stopw.txt'</span>)</span><br><span class="line"></span><br><span class="line">#segment为分词结果</span><br><span class="line">segment = wk[myfile.res]</span><br><span class="line"></span><br><span class="line">#对于分词结果进行正则过滤，去掉数字及字母</span><br><span class="line">segment = gsub(<span class="string">"[a-zA-Z\\/\\.0-9]+"</span>,<span class="string">""</span>,segment)</span><br><span class="line"></span><br><span class="line">#计算词频，该data即为传入词云的数据</span><br><span class="line">data &lt;- freq(segment)</span><br><span class="line"></span><br><span class="line">#引入wordcloud2，在引入之前请先安装</span><br><span class="line"> library(wordcloud2)  </span><br><span class="line"></span><br><span class="line">#调用wordcloud2函数绘制词云，该函数参数在github已有介绍</span><br><span class="line">  wordcloud2(data,size = <span class="number">1</span>, fontFamily = <span class="string">"微软雅黑"</span>,color = <span class="string">"random-light"</span><span class="string">")</span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1094385-9024949a3137c79c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算词频后的结果"></p><p><img src="http://upload-images.jianshu.io/upload_images/1094385-f9d22e28a612a9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我一开始万万没有想到我分出来会这么丑"></p><h3 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h3><p><strong>1.计算词频</strong></p><p>由于弹幕的条数比较多，分词过滤后的词频很多，没有细查找如何再进一步的排序过滤筛选词，所以导致词云的结果并不是很好</p><p><strong>2. 关键词提取</strong></p><p>个人认为通过关键字提取出的词云会更好一旦，<code>jiabaR</code>提供了关键字提取的方法及提取的结果，结果上面是词语出现频率。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提取150个关键字</span></span><br><span class="line"><span class="attr">keys</span> = worker(<span class="string">"keywords"</span>,topn=<span class="number">150</span>)</span><br><span class="line"><span class="comment">#关键字结果</span></span><br><span class="line"><span class="attr">re</span> = vector_keywords(segment,keys)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1094385-d6d5dae7d30132e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="提取出的关键字结果"><br>从图上可以看出这个关键词比较适合用来做词云，但是这里遇到了问题，关键字的结果时<code>vector</code>类型，并不能直接作为<code>wordcloud</code>的参数，从测试结果上来看<code>wordcloud</code>的参数接收<code>data.frame</code>类型，且要有词的内容和词频，当我通过如下代码将<code>vector</code>类型转换为<code>data.frame</code>时，并将结果输出到了<code>csv</code>的文件后发现，输出的内容并没有词频。<strong>没有词频就无法通过<code>wordcloud</code>来进行绘制！！！</strong>,<strong>求指教如何将关键词放入<code>wordcloud</code>进行绘制！！！</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#re为调用vector_keywords产生的结果</span></span><br><span class="line"><span class="class"><span class="keyword">data</span>.frame(<span class="title">re</span>);</span></span><br><span class="line"><span class="meta">#将结果输出到文件中</span></span><br><span class="line"><span class="title">write</span>.csv(<span class="class"><span class="keyword">data</span>.frame(<span class="title">re</span>),"<span class="type">F</span>:/<span class="type">R</span>/2345.csv",row.names = <span class="type">T</span>)</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1094385-87adec761690384e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过调用关键词函数vector_keywords产生的结果"></p><p><strong>3. 提出出的词语如何能文字更多</strong><br>在做词库处理时，我这边用了搜狗的词库替换了<code>jiabaR</code>的原来词库，因此可以出现类似于<code>神罗天征</code>这样的四字词语，在原来的词库里，连<code>宇智波</code>都是被分开的！但是如何把很短的一句话也提取出来呢，从最开始的弹幕可以看到，原文件中是有大量的重复的一句话，除了自己在搜狗词包之外设置固定的词语短句，不知道还有没有别的方法，欢迎指导。</p><h2 id="R语言分词end"><a href="#R语言分词end" class="headerlink" title="R语言分词end"></a>R语言分词end</h2><p>最后的那个图被我做的太丑了，简直影响观看，我如果一开始能预料到分出来会这么丑……我万万不会去分的，而且现在做云文字的网站都自带分词好像是，所以……所以我也不知道我这是在干嘛……。<strong>如有错误还请指教！</strong></p><p>在整个过程中遇到的调试记录请移步<a href="/2017/09/03/201709031632/">Python爬取B站弹幕+R语言分词安装调试报错记录</a></p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
